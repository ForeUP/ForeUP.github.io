<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://foreup.github.io/</id>
    <title>ForeUP&apos;s Blog</title>
    <updated>2022-02-01T11:07:46.929Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://foreup.github.io/"/>
    <link rel="self" href="https://foreup.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://foreup.github.io/images/avatar.png</logo>
    <icon>https://foreup.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, ForeUP&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[0201-Promise-JQuery选择]]></title>
        <id>https://foreup.github.io/post/0201-promise-jquery-xuan-ze/</id>
        <link href="https://foreup.github.io/post/0201-promise-jquery-xuan-ze/">
        </link>
        <updated>2022-02-01T11:07:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="promise">Promise</h1>
<p>最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：<br>
<code>resolve</code>和<code>reject</code>分别代表成功与失败执行的函数；</p>
<pre><code class="language-JavaScript">function test(resolve, reject) {
    var timeOut = Math.random() * 2;
    log('set timeout to: ' + timeOut + ' seconds.');
    setTimeout(function () {
        if (timeOut &lt; 1) {
            log('call resolve()...');
            resolve('200 OK'); //代表成功
        }
        else {
            log('call reject()...');
            reject('timeout in ' + timeOut + ' seconds.'); //代表失败
        }
    }, timeOut * 1000);
}
</code></pre>
<p>用一个Promise对象来执行上述函数，并根据设定的时间延迟显示结果；</p>
<pre><code class="language-JavaScript">var p1 = new Promise(test);
var p2 = p1.then(function (result) {
    console.log('成功：' + result);
}).catch(function (reason) {
    console.log('失败：' + reason);
});
</code></pre>
<p><code>Promise().then().then....catch()</code> 多任务串行执行.<br>
<code>Promise.all([p1,p2,...])</code> 多任务并行执行<br>
都要成功才进入then,返回结果数组.<br>
<code>Promise.race([p1,p2,...])</code> 多任务赛跑.<br>
then()和catch(),谁先调用算谁的,其它任务中断.</p>
<h2 id="canvas">Canvas</h2>
<ul>
<li>在HTML中设定一块画布的大小与ID等属性；</li>
<li>用JS在画图中绘画；</li>
</ul>
<pre><code class="language-JavaScript">var c=document.getElementById(&quot;myCanvas&quot;);
var ctx=c.getContext(&quot;2d&quot;);
//矩形
ctx.fillStyle=&quot;#FF0000&quot;;
ctx.fillRect(0,0,150,75);
//路径
ctx.moveTo(0,0); //线条开始坐标
ctx.lineTo(200,100); //线条结束坐标
ctx.stroke();
//文本
ctx.font=&quot;30px Arial&quot;; //字体
ctx.fillText(&quot;Hello World&quot;,10,50); //实心字
ctx.strokeText(&quot;Hello World&quot;,10,50); //空心字
//画圆
ctx.beginPath();
ctx.arc(95,50,40,0,2*Math.PI); //x,y,r,start,stop
ctx.stroke();
// ****创建渐变****
  //createLinearGradient(x,y,x1,y1) - 创建线条渐变
  //createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变
  var grd=ctx.createLinearGradient(0,0,200,0);
  grd.addColorStop(0,&quot;red&quot;);
  grd.addColorStop(1,&quot;white&quot;);
  // 填充渐变
  ctx.fillStyle=grd;
  ctx.fillRect(10,10,150,80);
//图像
var img=document.getElementById(&quot;scream&quot;);
ctx.drawImage(img,10,10);
</code></pre>
<h1 id="jquery选择器">JQuery选择器</h1>
<p><strong>按ID查找</strong><br>
<code>#abc</code>以<code>#</code>开头，返回的对象是jQuery对象；如果<code>id</code>为<code>abc</code>的<code>&lt;div&gt;</code>存在：返回的JQuery对象为<code>[&lt;div id=&quot;abc&quot;&gt;...&lt;/div&gt;]</code>；若不存在：返回<code>[]</code>。</p>
<pre><code class="language-JavaScript">// 查找&lt;div id=&quot;abc&quot;&gt;:
var div = $('#abc');
</code></pre>
<ul>
<li>DOM与JQuery相互转化</li>
</ul>
<pre><code class="language-JavaScript">var div = $('#abc'); // jQuery对象
var divDom = div.get(0); // 假设存在div，获取第1个DOM元素
var another = $(divDom); // 重新把DOM包装为jQuery对象
</code></pre>
<p><strong>按tag查找</strong></p>
<pre><code class="language-JavaScript">var ps = $('p'); // 返回所有&lt;p&gt;节点
ps.length; // 数一数页面有多少个&lt;p&gt;节点
</code></pre>
<p><strong>按class查找</strong><br>
注意在<code>class</code>名称前加<code>.</code></p>
<pre><code class="language-JavaScript">var a = $('.red'); // 所有节点包含`class=&quot;red&quot;`都将返回
// 例如:
// &lt;div class=&quot;red&quot;&gt;...&lt;/div&gt;
// &lt;p class=&quot;green red&quot;&gt;...&lt;/p&gt;
</code></pre>
<ul>
<li>查找<code>class</code>同时包含<code>red</code>和<code>green</code>的节点：</li>
</ul>
<pre><code class="language-JavaScript">var a = $('.red.green'); // 注意没有空格！
// 符合条件的节点：
// &lt;div class=&quot;red green&quot;&gt;...&lt;/div&gt;
// &lt;div class=&quot;blue green red&quot;&gt;...&lt;/div&gt;
</code></pre>
<p><strong>按属性查找</strong><br>
当属性存在空格<code></code> 等特殊字符时需要用双引号<code>&quot;&quot;</code>括起来；</p>
<pre><code class="language-JavaScript">var email = $('[name=email]'); // 找出&lt;??? name=&quot;email&quot;&gt;
var passwordInput = $('[type=password]'); // 找出&lt;??? type=&quot;password&quot;&gt;
var a = $('[items=&quot;A B&quot;]'); // 找出&lt;??? items=&quot;A B&quot;&gt;
</code></pre>
<p>属性的前缀后缀查找</p>
<pre><code class="language-JavaScript">var icons = $('[name^=icon]'); // 找出所有name属性值以icon开头的DOM
// 例如: name=&quot;icon-1&quot;, name=&quot;icon-2&quot;
var names = $('[name$=with]'); // 找出所有name属性值以with结尾的DOM
// 例如: name=&quot;startswith&quot;, name=&quot;endswith&quot;
var icons = $('[class^=&quot;icon-&quot;]'); // 找出所有class包含至少一个以`icon-`开头的DOM
// 例如: class=&quot;icon-clock&quot;, class=&quot;abc icon-home&quot;
</code></pre>
<p><strong>组合查找</strong></p>
<pre><code class="language-JavaScript">var emailInput = $('input[name=email]'); // 不会找出&lt;div name=&quot;email&quot;&gt;, 只查找&lt;input&gt;标签
//tag和class组合查找
var tr = $('tr.red'); // 找出&lt;tr class=&quot;red ...&quot;&gt;...&lt;/tr&gt;
</code></pre>
<p><strong>多项选择器</strong><br>
选出的元素按在HTML中的顺序排序，且不会有重复元素；<br>
<code>&lt;p class=&quot;red green&quot;&gt;</code>不会被下面的<code>$('p.red,p.green')</code>选择两次；</p>
<pre><code class="language-JavaScript">$('p,div'); // 把&lt;p&gt;和&lt;div&gt;都选出来
$('p.red,p.green'); // 把&lt;p class=&quot;red&quot;&gt;和&lt;p class=&quot;green&quot;&gt;都选出来
</code></pre>
<p><strong>以下内容以此为例</strong></p>
<pre><code class="language-html">&lt;!-- HTML结构 --&gt;
&lt;div class=&quot;testing&quot;&gt;
    &lt;ul class=&quot;lang&quot;&gt;
        &lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;
        &lt;li class=&quot;lang-python&quot;&gt;Python&lt;/li&gt;
        &lt;li class=&quot;lang-lua&quot;&gt;Lua&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<p><strong>层级选择器</strong><br>
用<code>$('ancestor descendant')</code>来选择，层级之间用空格隔开；</p>
<pre><code class="language-JavaScript">$('ul.lang li.lang-javascript'); // [&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;]
$('div.testing li.lang-javascript'); // [&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;]
</code></pre>
<p>选择所有的<code>&lt;li&gt;</code>节点：</p>
<pre><code class="language-JavaScript">$('ul.lang li');
$('form[name=upload] input'); //选择范围限定在name属性为upload的表单里
$('form.test p input'); // 多层选择,在form表单选择被&lt;p&gt;包含的&lt;input&gt;
</code></pre>
<p><strong>子选择器</strong><br>
<code>$('parent&gt;child')</code>类似层级选择器，但必须是直系父子关系；</p>
<pre><code class="language-JavaScript">$('ul.lang&gt;li.lang-javascript'); // 可以选出[&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;]
$('div.testing&gt;li.lang-javascript'); // [], 无法选出，因为&lt;div&gt;和&lt;li&gt;不构成父子关系
</code></pre>
<p><strong>过滤器</strong></p>
<pre><code class="language-JavaScript">$('ul.lang li'); // 选出JavaScript、Python和Lua 3个节点
$('ul.lang li:first-child'); // 仅选出JavaScript
$('ul.lang li:last-child'); // 仅选出Lua
$('ul.lang li:nth-child(2)'); // 选出第N个元素，N从1开始
$('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素
$('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素
</code></pre>
<h2 id="查找和过滤">查找和过滤</h2>
<p><strong>查找</strong></p>
<ul>
<li>获得一个节点<code>ul</code></li>
<li><code>ul.find()</code>节点内查找</li>
</ul>
<pre><code class="language-html">&lt;!-- HTML结构 --&gt;
&lt;ul class=&quot;lang&quot;&gt;
    &lt;li class=&quot;js dy&quot;&gt;JavaScript&lt;/li&gt;
    &lt;li class=&quot;dy&quot;&gt;Python&lt;/li&gt;
    &lt;li id=&quot;swift&quot;&gt;Swift&lt;/li&gt;
    &lt;li class=&quot;dy&quot;&gt;Scheme&lt;/li&gt;
    &lt;li name=&quot;haskell&quot;&gt;Haskell&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p><code>find()</code>查找：</p>
<pre><code class="language-JavaScript">var ul = $('ul.lang'); // 获得&lt;ul&gt;
var dy = ul.find('.dy'); // 获得JavaScript, Python, Scheme
var swf = ul.find('#swift'); // 获得Swift
var hsk = ul.find('[name=haskell]'); // 获得Haskell
</code></pre>
<p>向上查找，使用<code>parent()</code>：</p>
<pre><code class="language-JavaScript">var swf = $('#swift'); // 获得Swift
var parent = swf.parent(); // 获得Swift的上层节点&lt;ul&gt;
var a = swf.parent('.red'); // 获得Swift的上层节点&lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空jQuery对象
</code></pre>
<p>同一层级的节点，可以使用<code>next()</code>和<code>prev()</code>方法：</p>
<pre><code class="language-JavaScript">var swift = $('#swift');
swift.next(); // Scheme
swift.next('[name=haskell]'); // 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]
swift.prev(); // Python
swift.prev('.dy'); // Python，因为Python同时符合过滤器条件.dy
</code></pre>
<p><strong>过滤</strong><br>
和函数的<code>map</code>、<code>filter</code>类似：<br>
<code>filter()</code>过滤掉不符合条件的节点；</p>
<pre><code class="language-JavaScript">var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
var a = langs.filter('.dy'); // 拿到JavaScript, Python, Scheme
</code></pre>
<p>或者也可以传入函数，注意<code>this</code>的指向的对象为<code>DOM</code></p>
<pre><code class="language-JavaScript">var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
langs.filter(function () {
    return this.innerHTML.indexOf('S') === 0; // 返回S开头的节点
}); // 拿到Swift, Scheme
</code></pre>
<p><code>map()</code>把JQuery对象中的节点转化为数组或其他形式</p>
<pre><code class="language-JavaScript">var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
var arr = langs.map(function () {
    return this.innerHTML;
}).get(); // 用get()拿到包含string的Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell']
</code></pre>
<p>若JQuery包含多个节点，可以用<code>first()</code>、<code>last()</code>、<code>slice()</code>返回新的JQuery对象，删除不必要节点；</p>
<pre><code class="language-JavaScript">var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
var js = langs.first(); // JavaScript，相当于$('ul.lang li:first-child')
var haskell = langs.last(); // Haskell, 相当于$('ul.lang li:last-child')
var sub = langs.slice(2, 4); // Swift, Scheme, 参数和数组的slice()方法一致
</code></pre>
<h2 id="练习">练习</h2>
<p>对于下面表单，输入值后，用jQuery获取表单的JSON字符串，<code>key</code>和<code>value</code>分别对应每个输入的<code>name</code>和相应的<code>value</code>，例如：<code>{&quot;name&quot;:&quot;Michael&quot;,&quot;email&quot;:...}</code></p>
<pre><code class="language-HTML">&lt;form id=&quot;test-form&quot; action=&quot;#0&quot; onsubmit=&quot;return false;&quot;&gt;
    &lt;p&gt;&lt;label&gt;Name: &lt;input name=&quot;name&quot;&gt;&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Email: &lt;input name=&quot;email&quot;&gt;&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;Gender: &lt;label&gt;&lt;input name=&quot;gender&quot; type=&quot;radio&quot; value=&quot;m&quot; checked&gt; Male&lt;/label&gt; &lt;label&gt;&lt;input name=&quot;gender&quot; type=&quot;radio&quot; value=&quot;f&quot;&gt; Female&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;City: &lt;select name=&quot;city&quot;&gt;
    	&lt;option value=&quot;BJ&quot; selected&gt;Beijing&lt;/option&gt;
    	&lt;option value=&quot;SH&quot;&gt;Shanghai&lt;/option&gt;
    	&lt;option value=&quot;CD&quot;&gt;Chengdu&lt;/option&gt;
    	&lt;option value=&quot;XM&quot;&gt;Xiamen&lt;/option&gt;
    &lt;/select&gt;&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;!--****JS脚本****--&gt;
&lt;script&gt;
json = {};  //将json初始化为对象
// 利用和表单元素相关的特殊选择器
// 理解filter和map的机制
let tmp1 = $('#test-form :input').not('button').filter(function(){
    //console.log(this.type);
    return this.type !== 'radio' || this.checked;
}).map(function(){
    json[this.name] = this.value;
    return true;
});
json = JSON.stringify(json);
&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0131-DOM-文件-AJAX]]></title>
        <id>https://foreup.github.io/post/0131-dom-wen-jian-ajax/</id>
        <link href="https://foreup.github.io/post/0131-dom-wen-jian-ajax/">
        </link>
        <updated>2022-02-01T06:29:33.000Z</updated>
        <content type="html"><![CDATA[<p><strong>删除DOM</strong><br>
删除后子节点不在文档树中，但仍在内存中，可随时将其放到其他地方；</p>
<pre><code class="language-JavaScript">var willBeRemoved = document.getElementById(test-id);
var beRemovedParent = willBeRemoved.parentElement;
var removed = beRemovedParent.removeChild(willBeRemoved);
removed === willBeRemoved; //true;
</code></pre>
<p>ps：要注意，<code>children</code>属性是一个只读属性，删除多个节点时，要注意<code>children</code>属性时刻都在变化；</p>
<ul>
<li>练习删除Web开发不相关的节点</li>
</ul>
<pre><code class="language-JavaScript">let prt = document.getElementById('test-list');
let removeArr = ['JavaScript','HTML','CSS'];
Array.from(prt.children).forEach(function(x){removeArr.includes(x.innerText)? x : prt.removeChild(x);});
</code></pre>
<p><code>[\S]</code>查找非空白字符；</p>
<ul>
<li>注册信息验证练习：</li>
</ul>
<pre><code class="language-html">&lt;!-- HTML结构 --&gt;
&lt;form id=&quot;test-register&quot; action=&quot;#&quot; target=&quot;_blank&quot; onsubmit=&quot;return checkRegisterForm()&quot;&gt;
    &lt;p id=&quot;test-error&quot; style=&quot;color:red&quot;&gt;&lt;/p&gt;
    &lt;p&gt;
        用户名: &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;
    &lt;/p&gt;
    &lt;p&gt;
        口令: &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;
    &lt;/p&gt;
    &lt;p&gt;
        重复口令: &lt;input type=&quot;password&quot; id=&quot;password-2&quot;&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;
    &lt;/p&gt;
&lt;/form&gt;

&lt;!-- JavaScript 内容 --&gt;
&lt;script&gt;
var checkRegisterForm = function () {   
    let 
        usc = 0,
        psc = 0,
        in_us = document.getElementById('username'),
        in_ps = document.getElementById('password'),
        in_ps2 = document.getElementById('password-2');
    let 
        usexp = /[0-9a-zA-Z]{3,10}/,
        psexp = /[\S]{6,20}/;
    if(usexp.test(in_us.value)) {usc += 1;}
    if(!usexp.test(in_us.value)) {window.alert('用户名必须是3-10位英文字母或数字；'); return false;}
    if(psexp.test(in_ps.value)){psc += 1;}
    if(!psexp.test(in_ps.value)) {window.alert('口令必须是6-20位；'); return false;}
    if(in_ps.value!==in_ps2.value) {psc--; window.alert('两次口令必须一致；'); return false;}
    return usc&amp;&amp;psc; 
}
&lt;/script&gt;
</code></pre>
<h2 id="操作文件">操作文件</h2>
<ul>
<li>以预览图片为例</li>
</ul>
<pre><code class="language-html">&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;p&gt;图片预览：&lt;/p&gt;
    &lt;p&gt;&lt;/p&gt;
    &lt;div id=&quot;test-image-preview&quot; style=&quot;border: 3px solid #ff0000; border-radius: 10px; width: 33%; height: 200px; background-size: contain; background-repeat: no-repeat; background-position: center center;&quot;&gt;
    &lt;/div&gt;
    &lt;p&gt;&lt;/p&gt;
    &lt;p&gt;
      &lt;input type=&quot;file&quot; id=&quot;test-image-file&quot; name=&quot;test&quot;&gt;
    &lt;/p&gt;
    &lt;p id=&quot;test-file-info&quot;&gt;没有选择文件&lt;/p&gt;
&lt;/form&gt;
</code></pre>
<p><strong>js代码及说明</strong><br>
<code>FileReader()</code>对象用来读取文件；<br>
<code>element.target.result</code>将图片编码为<code>base64</code>数据；<br>
<code>preview.style.backgroundImage = 'url(' + data + ')';</code>显示图片；</p>
<pre><code class="language-javascript">//确定js在HTML后加载
window.onload = function() {
var
    fileInput = document.getElementById('test-image-file'),
    info = document.getElementById('test-file-info'),
    preview = document.getElementById('test-image-preview');
// 监听change事件:
fileInput.addEventListener(&quot;change&quot;, previewFunc);
function previewFunc () {
    // 清除背景图片:
    preview.style.backgroundImage = '';
    // 检查文件是否选择:
    if (!fileInput.value) {
        info.innerHTML = '没有选择文件';
        return;
    }
    // 获取File引用:
    var file = fileInput.files[0];
    // 获取File信息:
    info.innerHTML = '文件: ' + file.name + '&lt;br&gt;' +
                     '大小: ' + file.size + '&lt;br&gt;' +
                     '修改: ' + file.lastModified;
    if (file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif') {
        alert('不是有效的图片文件!');
        return;
    }
    // 读取文件:
    var reader = new FileReader();
    reader.onload = function(e) {
        var data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'            
        preview.style.backgroundImage = 'url(' + data + ')';
        console.log(data);
    };
    // 以DataURL的形式读取文件:
    reader.readAsDataURL(file);
}
} //确定js在HTML后加载
</code></pre>
<h2 id="ajax入门">AJAX入门</h2>
<p><code>var xhttp = new XMLHttpRequest();</code>创建<code>xhttp</code>为名的<code>XMLHttpRequest</code>的对象；<br>
<code>xhttp.onreadystatechange = function() { ... }</code>当<code>XMLHttpRequest</code>的状态改变时回调函数；<br>
<code>xmlhttp.readyState</code>：</p>
<blockquote>
<ul>
<li>0: 请求未初始化</li>
<li>1: 服务器连接已建立</li>
<li>2: 请求已接收</li>
<li>3: 请求处理中</li>
<li>4: 请求已完成，且响应已就绪</li>
</ul>
</blockquote>
<p><code>xmlhttp.status</code>：</p>
<blockquote>
<ul>
<li>200: &quot;OK&quot;</li>
<li>404: 未找到页面</li>
</ul>
</blockquote>
<pre><code class="language-javascript">xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/gethint.php?q=&quot;+str,true);
xmlhttp.send();
</code></pre>
<p><code>open(method,url,async)</code>使<code>readyState</code>改变：</p>
<blockquote>
<p>method：请求的类型；GET 或 POST，大小写均可；</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0130-继承-DOM-HTML排序]]></title>
        <id>https://foreup.github.io/post/0130-dom-html-pai-xu/</id>
        <link href="https://foreup.github.io/post/0130-dom-html-pai-xu/">
        </link>
        <updated>2022-01-30T13:15:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="原型继承">原型继承</h2>
<ol>
<li>创建新函数，并使用<code>call()</code>绑定<code>this</code>；</li>
<li>使用空函数<code>new F()</code>指向父原型；</li>
<li>修复子原型的<code>constructor</code>为子原型；</li>
<li>尽量将封装一个<code>inherits</code>函数实现继承；<br>
<strong>例子</strong></li>
</ol>
<pre><code class="language-javascript">function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}
</code></pre>
<ul>
<li>通过inherits继承原型</li>
</ul>
<pre><code class="language-javascript">function Student(props) {
    this.name = props.name || 'Unnamed';
}
Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}

function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};
</code></pre>
<p>ES6新增的<code>class</code>可以使原型的继承更为简单</p>
<pre><code class="language-javascript">//父对象模型
class Student {
    constructor(name) {
        this.name = name;
    }
    hello() {
        alert('Hello, ' + this.name + '!');
    }
}
//新建对象
var xiaoming = new Student('小明');
xiaoming.hello();
//子对象模型
class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert('I am at grade ' + this.grade);
    }
}
</code></pre>
<h2 id="dom选择相关">DOM选择相关</h2>
<pre><code class="language-javascript">document.getElementById()  //具有唯一性
document.getElementsByTagName()   //不具有唯一性，返回一组DOM节点
document.getElementsByClassName()   //不具有唯一性
// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：
var trs = document.getElementById('test-table').getElementsByTagName('tr');
// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：
var reds = document.getElementById('test-div').getElementsByClassName('red');
// 获取节点test下的所有直属子节点:
var cs = test.children;
// 获取节点test下第一个、最后一个子节点：
var first = test.firstElementChild;
var last = test.lastElementChild;
// 通过querySelector获取ID为q1的节点：
var q1 = document.querySelector('#q1');
// 通过querySelectorAll获取q1节点内的符合条件的所有节点：
var ps = q1.querySelectorAll('div.highlighted &gt; p');
//练习，评论区回答
var arr = document.querySelectorAll('.c-red.c-green&gt;p');
var arr = document.getElementsByClassName('c-red c-green')[0].children;
var arr = document.querySelectorAll(&quot;.c-red.c-green p&quot;);
// 选择&lt;p&gt;Haskell&lt;/p&gt;:
var haskell = document.querySelector(&quot;#test-div div:last-child p:last-child&quot;);

p.innerHTML = 'ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ';
p.innerText = 'ABC';
// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;
var p = document.getElementById('p-id');
// 设置CSS:
p.style.color = '#ff0000';
p.style.fontSize = '20px';
p.style.paddingTop = '2em';
</code></pre>
<p><strong>插入DOM</strong></p>
<ul>
<li>插入最后<br>
DOM节点为空，如，<code>&lt;div&gt;&lt;/div&gt;</code>，使用<code>innerHTML = '&lt;span&gt;child&lt;/span&gt;'</code>插入新的子节点，但会覆盖原来的子节点；<br>
若非空，则可以用<code>appendChild</code>把一个子节点添加到父节点的最后一个子节点。<br>
原结构：</li>
</ul>
<pre><code class="language-html">&lt;!-- HTML结构 --&gt;
&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;
&lt;div id=&quot;list&quot;&gt;
    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;
    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;
    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>把<code>&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;</code>添加到<code>&lt;div id=&quot;list&quot;&gt;</code>的最后一项：</p>
<pre><code class="language-javascript">var
    js = document.getElementById('js'),
    list = document.getElementById('list');
list.appendChild(js);
</code></pre>
<p>修改后的结构：</p>
<pre><code class="language-HTML">&lt;!-- HTML结构 --&gt;
&lt;div id=&quot;list&quot;&gt;
    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;
    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;
    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;
    &lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>上面是把之前存在的节点移动到新位置，更多需要新建节点，应该如下：<br>
新语句：<br>
<code>document.createElement('p');</code>——创建元素；<br>
<code>d.setAttribute('type', 'text/css');</code>——设置对象属性；</p>
<pre><code class="language-javascript">var
    list = document.getElementById('list'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.appendChild(haskell);

var d = document.createElement('style');
d.setAttribute('type', 'text/css');
d.innerHTML = 'p { color: red }'; //‘p’用来确定是&lt;p&gt;还是其他，如&lt;h1&gt;等；
document.getElementsByTagName('head')[0].appendChild(d);
</code></pre>
<ul>
<li>插入指定位置<br>
使用<code>parentElement.insertBefore(newElement, referenceElement);</code>，插入到<code>referenceElement</code>之前</li>
</ul>
<pre><code class="language-html">&lt;!-- HTML结构 --&gt;
&lt;div id=&quot;list&quot;&gt;
    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;
    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;
    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
var
    list = document.getElementById('list'),
    ref = document.getElementById('python'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.insertBefore(haskell, ref);
&lt;/script&gt;
&lt;!-- *新* HTML结构 --&gt;
&lt;div id=&quot;list&quot;&gt;
    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;
    &lt;p id=&quot;haskell&quot;&gt;Haskell&lt;/p&gt;
    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;
    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>循环一个父节点的所有子节点，可以通过迭代<code>children</code>属性实现将所有子节点写入某数组中；<br>
复习下面的代码：</p>
<pre><code class="language-html">&lt;!-- HTML结构 --&gt;
&lt;ol id=&quot;test-list&quot;&gt;
    &lt;li class=&quot;lang&quot;&gt;Scheme&lt;/li&gt;
    &lt;li class=&quot;lang&quot;&gt;JavaScript&lt;/li&gt;
    &lt;li class=&quot;lang&quot;&gt;Python&lt;/li&gt;
    &lt;li class=&quot;lang&quot;&gt;Ruby&lt;/li&gt;
    &lt;li class=&quot;lang&quot;&gt;Haskell&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p><strong>对HTML内容排序</strong></p>
<pre><code class="language-javascript">//直接排序
list = document.getElementById('test-list');
sort = Array.from(list.children).sort((a, b) =&gt; a.innerText &gt; b.innerText ? 1:-1);
for (let e of sort) list.appendChild(e);
//获取文本排序后返回
list = Array.from(document.getElementById('test-list').children);
sort = list.map(element =&gt; element.innerText).sort();
list.map((element, index) =&gt; element.innerText = sort[index])
//自己最开始写的笨方法
let c = [];
let pz = document.getElementById('test-list');
for(let i = 0; i &lt; pz.children.length; i++){
  c[i] = pz.children[i].innerText;
}
let s = c.sort();
let ht;
for (x of s){
  ht = ht + '&lt;li class=&quot;lang&quot;&gt;' + x +'&lt;/li&gt;' + &quot; &quot;;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0129小结]]></title>
        <id>https://foreup.github.io/post/0129-xiao-jie/</id>
        <link href="https://foreup.github.io/post/0129-xiao-jie/">
        </link>
        <updated>2022-01-29T10:58:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="大纲">大纲</h2>
<ul>
<li><em>filter去重</em></li>
<li><em>filter筛选数组中素数</em></li>
<li><em>sort()函数复习</em></li>
<li><em>Array对象</em></li>
<li><em>函数闭包</em></li>
<li><em>箭头函数</em></li>
<li><em>generator对象</em></li>
<li><em>正则表达与Date对象</em></li>
<li><em>Jason</em></li>
</ul>
<h2 id="filter去重">filter去重</h2>
<pre><code class="language-javascript">var r,
arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];
r = arr.filter(function (element, index, self) {
    return self.indexOf(element) === index;});
//PS:element, index, self只是形式？不知道能不能换！
</code></pre>
<h2 id="filter筛选素数">filter筛选素数</h2>
<p>简单的方法可以考虑素数只有<code>1和本身</code>两个因数，麻烦的可以依据定义写函数</p>
<pre><code class="language-javascript">//获得素数函数，可以利用素数只有两个因数，下面的是麻烦的，从定义写的函数！
function get_primes(arr) {
    var brr = arr.filter(function(ss){ 
    var jsw = 0;
    if (ss == 1) {jsw =1}
    else {
    for (var i=2; i&lt;ss; i++) {
    if( ss%i==0 ){
        jsw = jsw +1;
        break;}
    else{ continue; }
    }
} 
     return !jsw;
 });
return brr;
}
//依据因数是否只有2个
arr = arr.filter(function(element, index, self){
    var count = 0;//记录因数的数量
    for(var i=1;i&lt;=element;i++){
       if(element%i===0){
          count++;
        }
    }
    if(element===1){
      return false;
    }
   return count&lt;3;
});
console.log(arr)
</code></pre>
<h2 id="sort函数">sort函数</h2>
<p>在3w网站学过，快速排序，按照<code>-1,0,1</code>的顺序，也可以排列有属性的对象</p>
<pre><code class="language-javascript">//数字小-&gt;大排序；
points.sort(function(a, b){return a - b}); 
//随机排序数组；
points.sort(function(a, b){return 0.5 - Math.random()});
//排序有属性数组,按照字母排序对象
cars.sort(function(a, b){return a.year - b.year});；
function myFunction() {
	var cars = [{type:&quot;BMW&quot;, year:2017},{type:&quot;Audi&quot;, year:2019},{type:&quot;porsche&quot;, year:2018}];
  cars.sort(function(a, b){
    var x = a.type.toLowerCase();
    var y = b.type.toLowerCase();
    if (x &lt; y) {return -1;}
    if (x &gt; y) {return 1;}
    return 0;
  });
  displayCars();
}
</code></pre>
<h2 id="array">Array</h2>
<p>every</p>
<pre><code class="language-jacascript">var arr = ['Apple', 'pear', 'orange'];
console.log(arr.every(function (s) {
    return s.length &gt; 0;
})); // true, 因为每个元素都满足s.length&gt;0
</code></pre>
<p>find<br>
查找符合条件的<strong>第一个</strong>元素，如果找到了，<strong>返回这个元素</strong>；否则返回<code>undefined</code></p>
<pre><code class="language-javascript">var arr = ['Apple', 'pear', 'orange'];
console.log(arr.find(function (s) {
    return s.toLowerCase() === s;
})); // 'pear', 因为pear全部是小写
</code></pre>
<p>findIndex<br>
和<code>find</code>类似，区别：<code>findIndex()</code>会返回这个元素的索引，如果没有找到，返回<code>-1</code>;<br>
forEach<br>
<code>forEach()</code>和<code>map()</code>类似，但不会返回新数组;</p>
<h2 id="函数闭包">函数闭包</h2>
<p>把函数作为结果值返回，返回函数不要引用任何循环变量，或者<strong>后续会发生变化的变量</strong>：再<strong>创建一个函数</strong>，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已<strong>绑定</strong>到函数参数的值不变：</p>
<pre><code class="language-javascript">function count() {
    var arr = [];
    for (var i=1; i&lt;=3; i++) {
        arr.push((function (n) {
            return function () {
                return n * n;
            }
        })(i));
    }
    return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];
f1(); // 1
f2(); // 4
f3(); // 9
</code></pre>
<ul>
<li>用了一个“创建一个匿名函数并立刻执行”的语法：</li>
</ul>
<pre><code class="language-JavaScript">(function (x) {
    return x * x;
})(3); // 9
</code></pre>
<ul>
<li>只有函数的语言里，借助闭包，可以封装一个私有变量。我们用JavaScript创建一个计数器：</li>
</ul>
<pre><code class="language-JavaScript">'use strict';
function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}
</code></pre>
<ul>
<li>使用：</li>
</ul>
<pre><code class="language-javascript">var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
</code></pre>
<ul>
<li>闭包可以把<strong>多参数</strong>的函数变成<strong>单参数</strong>的函数:</li>
</ul>
<pre><code class="language-javascript">function make_pow(n) {
    return function (x) {
        return Math.pow(x, n);
    }
}

// 创建两个新函数:
var pow2 = make_pow(2);
var pow3 = make_pow(3);

console.log(pow2(5)); // 25
console.log(pow3(7)); // 343
</code></pre>
<h2 id="箭头函数">箭头函数</h2>
<p><code>this</code>的指向与标准<code>function</code>不同，始终指向词法作用域(还是挺糊涂的，以后遇到实例再说吧)；</p>
<pre><code class="language-javascript">var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
        return fn();
    }
};
</code></pre>
<p>箭头函数修复了<code>this</code>的指向</p>
<pre><code class="language-javascript">var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};
obj.getAge(); // 25
</code></pre>
<h2 id="generator">generator</h2>
<p><code>generator</code>由<code>function*</code>定义，可以用<code>yield</code>多次返回，也可以和函数一样用<code>return</code>返回一次。</p>
<pre><code class="language-javascript">function* fib2(max){
    var a=0, b=1, t;
    for (var i = 0; i&lt;max; i++) { 
        t=a;  //也可以直接执行 yield a;
        [a,b]=[b,a+b];
        yield t;
    }
}
//generator的调用，有两种方式
for (var shc of fib2(5)){
    console.log(shc);
}
</code></pre>
<ul>
<li>也可以用<code>next()</code>调用；</li>
</ul>
<pre><code class="language-javascript">var f = fib(5);
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 2, done: false}
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}
</code></pre>
<p>学了AJAX以后可以体会到generator更大的好处，目前只知道可以保存函数的中间状态；</p>
<h2 id="regexp相关">RegExp相关</h2>
<ul>
<li>基本知识<br>
<code>\w</code>可以匹配一个字母或数字，<code>\d</code>匹配一个数字；<br>
<code>+</code>表示至少一个字符：<code>\s+</code>表示至少有一个空格；<br>
<code>*</code>表示任意个字符，<code>?</code>表示0个或1个字符；<br>
<code>\d{3,8}</code>表示3-8个数字，如<code>'1234567'</code>等；<br>
匹配<code>'010-12345'</code>，<code>-</code>是特殊字符，需要转义，所以号码的正则是<code>\d{3}\-\d{3,8}</code>；<br>
<code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]*</code>表示由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串；<br>
<code>A|B</code>可以匹配A或B：<code>(J|j)ava(S|s)cript</code>；<br>
<code>^</code>表示行的开头，<code>^\d</code>必须以数字开头；<br>
<code>$</code>表示行的结束，<code>\d$</code>必须以数字结束：<code>js</code>也可以匹配<code>jsp</code>，但<code>js$</code>只能匹配<code>js</code>;</li>
<li>创建正则表达式：</li>
</ul>
<pre><code class="language-javascript">var re1 = /ABC\-001/;
var re2 = new RegExp('ABC\\-001');

re1; // /ABC\-001/
re2; // /ABC\-001/
</code></pre>
<ul>
<li>切分字符串</li>
</ul>
<pre><code class="language-javascript">'a b   c'.split(' '); // ['a', 'b', '', '', 'c'];
'a b   c'.split(/\s+/); // ['a', 'b', 'c'];
'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd'];
//至少一个[' '或','或';']
'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd'];
</code></pre>
<ul>
<li>分组<br>
除了匹配外，正则还可以提取字符串，<code>()</code>表示的就是要提取的分组；</li>
</ul>
<pre><code class="language-JavaScript">//先匹配字符串
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
</code></pre>
<p><code>exec()</code>方法在匹配成功后，会返回一个<code>Array</code>，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串；失败则会返回<code>null</code>。</p>
<pre><code class="language-JavaScript">var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;
re.exec('19:05:30'); // ['19:05:30', '19', '05', '30']
</code></pre>
<p>上述可以识别合法日期。<br>
但是对于日期的识别可能会出问题：</p>
<pre><code class="language-JavaScript">var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/;
</code></pre>
<p>对于<code>'2-30'</code>，<code>'4-31'</code>非法日期正则很难去识别，需要程序实现；</p>
<ul>
<li>贪婪匹配：正则<strong>默认贪婪</strong>匹配</li>
</ul>
<pre><code class="language-JavaScript">var re = /^(\d+)(0*)$/;
re.exec('102300'); // ['102300', '102300', '']
</code></pre>
<p>导致<code>0*</code>无法匹配到字符串，可以加个<code>？</code>来解决(尽可能少匹配)：</p>
<pre><code class="language-JavaScript">var re = /^(\d+?)(0*)$/;
re.exec('102300'); // ['102300', '1023', '00']
</code></pre>
<ul>
<li>全局匹配<br>
<code>g</code>，表示全局匹配；<code>i</code>，表示忽略大小写；<code>m</code>，表示多行匹配。</li>
</ul>
<pre><code class="language-JavaScript">var r1 = /test/g;
// 等价于:
var r2 = new RegExp('test', 'g');
</code></pre>
<p>全局匹配可以多次执行<code>exec()</code>方法来搜索一个匹配的字符串，指定<code>g</code>标志后，每次运行<code>exec()</code>，正则表达式本身会更新<code>lastIndex</code>属性，表示上次匹配到的最后索引：</p>
<pre><code class="language-JavaScript">var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;
// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10
re.exec(s); // ['VBScript']
re.lastIndex; // 20
re.exec(s); // ['JScript']
re.lastIndex; // 29
re.exec(s); // ['ECMAScript']
re.lastIndex; // 44
re.exec(s); // null，直到结束仍没有匹配到
</code></pre>
<p>全局匹配不能使用不能使用<code>/^...$/</code></p>
<h2 id="jason学习">Jason学习</h2>
<p>学习中看了篇评论区文章，箭头函数不乱用，箭头函数本身无this、arguments等属性，使用箭头函数一定要在外层套一层函数，使this在可见范围内，对象无法分割作用域（对象内的箭头函数无法确定this的指向），定义变量const&gt;let&gt;var尽量依次使用。</p>
<h2 id="创建对象">创建对象</h2>
<p>通过函数创建对象，理解还较浅，注意<code>prototype</code>与<code>__proto__</code>以及<code>原型链</code></p>
<pre><code class="language-javascript">function Cat(name) {
    this.name = name;
}
Cat.prototype.say = function(){
    return 'Hello, ' + this.name + '!';
}
</code></pre>
<p>可以用一个<code>createStudent</code>来内部封装<code>new</code></p>
<pre><code class="language-JavaScript">function Student(props) {
	this.name = props.name || '匿名';
	this.grade = props.grade || 1;
}

Student.prototype.hello = function () {
	alert('Hello, ' + this.name + '!');
}

function createStudent(props) {
	return new Student(props || {})
}
</code></pre>
<p><code>createStudent</code>的参数非常灵活，可以不传也可以如下：</p>
<pre><code class="language-JavaScript">var xiaoming = createStudent({
	name: '小明'
});

xiaoming.grade; 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0128小结]]></title>
        <id>https://foreup.github.io/post/0128-xiao-jie/</id>
        <link href="https://foreup.github.io/post/0128-xiao-jie/">
        </link>
        <updated>2022-01-28T08:32:42.000Z</updated>
        <content type="html"><![CDATA[<p>看完了<a href="https://www.w3school.com.cn/js/index.asp"><strong>w3school JS教程</strong></a>发现教程太长，太啰嗦了，太基础了，各种重复，因此打算去**<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021087191360">廖雪峰</a>** 那学，过几天看看效果吧，下面看看今天在<br>
<strong>w3那总结的东西：</strong></p>
<pre><code class="language-html">&lt;script&gt;
myarray.foreach()
    function myFunction(value, index, array) { txt = txt + value + &quot;&lt;br&gt;&quot;; }  //value:项目值，index：索引，array：数组本身；
    myarray.map()    //对每个元素执行函数创建新数组，不会对没有值元素执行，不改变原来数组；   
    numbers.reduce(function1,100)   // return total + value; total 总数（初始值/先前返回的值）,可定义一个初始值, reduceRight()
    var over18 = numbers.filter(myFunction);  //function{ return value &gt;18 ; },创建通过测试的新数组；
    numbers.every()    //方法检查所有数组值是否通过测试,some()检查某些数组值.
    mynum.find()    //方法返回通过测试函数的第一个数组元素的值,findIndex()返回索引；
    -----'日期'------
    new Date(2018, 11, 24, 10, 33, 30);  //年、月、日、小时、分钟、秒,0为一月；
    var d = new Date(&quot;October 13, 2014 11:13:00&quot;); //日期存储为自 1970 年 1 月 1 日 00:00:00 UTC以来的毫秒数;
    document.getElementById(&quot;demo&quot;).innerHTML = d;  //d为日期对象，会使用 toString()自动转换为字符串；
    d.toUTCString();  d.toDateString();   //转换为易读的日期字符串
    ISO日期格式：&quot;2018-02-19&quot; （国际标准），严格符合JS标准
    new Date(&quot;2019&quot;); 与 new Date(2019); 不同；
    短日期通常使用 &quot;MM/DD/YYYY&quot; 格式；
    var d = new Date();
    d.getDate()   以数值返回天（1-31）  d.getUTCDate()  
    d.getDay()    以数值获取周名（0-6）
    d.getFullYear()   获取四位的年（yyyy）
    d.getHours()  获取小时（0-23）
    d.getMilliseconds()   获取毫秒（0-999）
    d.getMinutes()    获取分（0-59）
    d.getMonth()  获取月（0-11）
    d.getSeconds()    获取秒（0-59）
    d.getTime()   获取时间（从 1970 年 1 月 1 日至今的毫秒数）
    -----'数学'------
    Math.round(x)     返回 x 四舍五入为最接近的整数；
    Math.pow(x, y)    返回 x 的 y 次幂；
    Math.sqrt(x)    返回 x 的平方根；
    Math.ceil(x)   返回 x '上舍入' 最接近的整数
    Math.floor(x)   '下舍入'
    Math.sin(x)    返回角 x弧度 的正弦
&lt;/script&gt;
&lt;script&gt;
var add = (function () {
  var counter = 0;
  return function () {counter += 1; return counter;}
})();

function myFunction(){
  document.getElementById(&quot;demo&quot;).innerHTML = add();
}
&lt;/script&gt;
</code></pre>
<p>廖雪峰中个人认为<strong>有用的练习</strong><br>
2.不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数</p>
<pre><code class="language-html">&lt;script&gt;
var s = '123456789';
var arr = [];
for( var a of s ){ arr.push(a) }
console.log(arr);
//ASCII码，数字字符的ASCII码 - '0'的ASCII码值 = 数字字符的数值
//var brr = arr.map(function(x){ return x - '0' ;});
var brr = arr.map(function(x){ return x * 1;});
console.log(brr);
//转换为整数
var c = brr.reduce(function(x,y){ return x * 10 + y; });
console.log(c);
&lt;/script&gt;
</code></pre>
<p>3.把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字</p>
<pre><code class="language-html">&lt;script&gt;
var arr = ['adam', 'LISA', 'barT'];
var l3arr = arr.map(function(x){return x[0].toUpperCase()+x.slice(1).toLowerCase();});
console.log(l3arr);
&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0127学习笔记]]></title>
        <id>https://foreup.github.io/post/0127-xue-xi-bi-ji/</id>
        <link href="https://foreup.github.io/post/0127-xue-xi-bi-ji/">
        </link>
        <updated>2022-01-27T11:58:29.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;学过的语法记录&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type=&quot;&quot;&gt;
    /*onchange	HTML 元素已被改变
    onclick	用户点击了 HTML 元素
    onmouseover	用户把鼠标移动到 HTML 元素上
    onmouseout	用户把鼠标移开 HTML 元素
    onkeydown	用户按下键盘按键
    onload	浏览器已经完成页面加载*/

    concat()
    indexOf()
    lastIndexOf()
    /*搜索字符串*/
    search()
    slice()
    substring()
    substr()
    --------------
    replace()
    toUpperCase()
    toLowerCase()
    mystring.trim()
    --------------
    提取字符串
    charAt() //返回字母
    charCodeAt() // 返回编码值
    str[0];   // str = &quot;HELLO WORLD&quot;，返回 H；

    text.match(/ain/g)    // 返回数组 [ain,ain,ain]
    text.match(/ain/gi)    // 返回数组 [ain,AIN,ain,ain]
    string.includes(searchvalue, start) //start 起始位置可选
    text.includes(&quot;world&quot;)    // 返回 true
    string.startsWith(searchvalue, start)
    text.startsWith(&quot;Hello&quot;)   // 字符串以Hello开头，返回 true
    text.endsWith(&quot;Doe&quot;, 5)    // 返回 true
    let text = &quot;Bill Gates&quot;;
    text.endsWith(&quot;Gates&quot;,10); //指定长度后必须严格和长度一致，9或11均为 false
    /*模板字面量*/
    let text = `He's often called &quot;Johnny&quot;`;  //反引号允许多行字符串
    let text =
    `The quick the    
    lazy dog`;
    let firstName = &quot;John&quot;;
    text = `Welcome ${firstName}!`;  //字符串插值（string interpolation）,变量和表达式插入字符串
    total = `Total: ${(price * (1 + VAT)).toFixed(3)}`; //price=10，VAT=0.25,；
    let html = `&lt;h2&gt;${header}&lt;/h2&gt;&lt;ul&gt;`; //HTML模板，具体例子太长；
    isNaN(x);               // 返回 true，因为 x 不是数；
    typeof Infinity;     //返回number，是超出计算的数字；
    0x;         //解释为16进制；
    number.toString(16);     // 返回 80，toString()以字符串形式输出为指定进制，默认10；
    x.toExponential(2);   //（）内为小数点后位数；
    mynum.toFixed(num); //num确定保留以四舍五入保留几位小数；
    toPrecision()      返回字符串值，指定长度的'数字'
    new Number(500);    //不要用new定义对象，JS中对象无法进行比较；
    valueOf()     //以数值返回数值
    Number()
    parseInt()
    parseFloat()
    MAX_VALUE ; MIN_VALUE; 对变量、表达式或值使用数字属性，将返回 undefined;
    ----/数组方法/----
    Array.foreach()  //遍历数组
    fruits.push(&quot;Lemon&quot;);    // 向 fruits 添加一个新元素 (Lemon)，返回字符串长度，使用高索引添加会增加“洞/undefined”
    pop()    //从数组中弹出元素，返回弹出的值；
    shift()   //从首部移出元素
    unshift()   //从首部增加元素
    delete fruits[0];   // 把 fruits 中的首个元素改为 undefined,尽量不用
    myarray.toString()     //把数组转换为数组值（逗号分隔）的字符串
    myarray.join()      //可以规定结合成为字符串的分割符
    fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;);   //第二个参数（0）定义应删除多少元素,返回一个包含已删除项的数组
    fruits.splice(0, 1);     // 删除 fruits 中的第一个元素
    fruits.slice()    //用fruits的某个片段切出新数组,不删除改变fruits，start位置(,end位置)；
    fruits.sort()    //方法是最强大的数组方法之一,按字母排序；
    points.sort(function(a, b){return a - b});  //数字小-&gt;大排序；
    points.sort(function(a, b){return 0.5 - Math.random()});   //随机排序数组；
    Math.max(1, 2, 3); Math.min(1, 2, 3);
    cars.sort(function(a, b){return a.year - b.year});  //排序有属性数组；
    

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Github Pages与GRidea搭建静态博客]]></title>
        <id>https://foreup.github.io/post/github-pages-yu-gridea-da-jian-jing-tai-bo-ke/</id>
        <link href="https://foreup.github.io/post/github-pages-yu-gridea-da-jian-jing-tai-bo-ke/">
        </link>
        <updated>2022-01-25T10:15:20.000Z</updated>
        <summary type="html"><![CDATA[<p>说不清的辛酸与累啊，以后看情况更新今天所经历的挫折吧！<br>
FLAG：每日一篇总结性文章（包括前端学习、C++学习等）</p>
]]></summary>
        <content type="html"><![CDATA[<p>说不清的辛酸与累啊，以后看情况更新今天所经历的挫折吧！<br>
FLAG：每日一篇总结性文章（包括前端学习、C++学习等）</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://foreup.github.io/post/hello-gridea/</id>
        <link href="https://foreup.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>