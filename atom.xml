<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://foreup.github.io/</id>
    <title>ForeUP&apos;s Blog</title>
    <updated>2022-02-15T09:21:10.238Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://foreup.github.io/"/>
    <link rel="self" href="https://foreup.github.io/atom.xml"/>
    <subtitle>Daily Notes</subtitle>
    <logo>https://foreup.github.io/images/avatar.png</logo>
    <icon>https://foreup.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, ForeUP&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[0215-New C++]]></title>
        <id>https://foreup.github.io/post/0215-new-c/</id>
        <link href="https://foreup.github.io/post/0215-new-c/">
        </link>
        <updated>2022-02-15T09:20:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="画树">画树</h2>
<pre><code class="language-python">from turtle import Turtle,done,colormode,setup,title
from random import randint,uniform

title('给我一点时间，还你一棵树')
colormode(255)      #设置画笔颜色模式，为随机生成RGB色彩做准备
p1 = Turtle()       #实例化一个画笔
p1.width(20)       #设置画笔宽度，初始宽度，主树干宽度
p1.speed(100)      #设置画笔速度，具体是多少最快，查阅一下
p1.pencolor(randint(0,254),randint(0,254),randint(0,254))      #初始画笔颜色,这是随机颜色，可以用0,0,0,表示黑色
p1.hideturtle()    #隐藏画笔外形
l = 150   #初始树干长度
s = 45    #侧枝生长角度  ，这里可以改，观察生长状态
p1.lt(90)          #默认画笔在画布正中央，方向向右，lt(90)调整为向上。
p1.penup()         #提起画笔，以便直接调整画笔位置，移动路径画布上没有痕迹
p1.bk(l)           #向后（向下）移动，调整树干起点
p1.pendown()       #落下画笔，可以继续画
p1.fd(l)           #画主树干
plist = [p1]       #列表化画笔，便于树干分支控制
def draw_tree(plist,l,s,level):      #参数level为分支层数，数值越大分支越多，相对画的时间也越长。
    l = l*uniform(0.7,0.8)           #分支树干为上一个的随机比例，这里可以改
    for p1 in plist:
        w = p1.width()
        p1.width(w*3/4)
        p1.pencolor(randint(0,254),randint(0,254),randint(0,254))
        p2 = p1.clone()
        p1.lt(s)
        p1.fd(l)
        p2.rt(s)
        p2.fd(l)
        lst = []
        lst.append(p1)
        lst.append(p2)
        if level &gt; 0:
            draw_tree(lst,l,s,level-1)
draw_tree(plist,l,s,5)

done()
</code></pre>
<h1 id="开始c暂停python">开始C++，暂停Python</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0214-第三方模块]]></title>
        <id>https://foreup.github.io/post/0214-di-san-fang-mo-kuai/</id>
        <link href="https://foreup.github.io/post/0214-di-san-fang-mo-kuai/">
        </link>
        <updated>2022-02-14T11:13:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pillow模块">pillow模块</h2>
<p><strong>制作验证码</strong></p>
<ul>
<li>编写返回随机颜色与随机字符的函数</li>
<li>创建图片画布</li>
<li>创建文字</li>
<li>创建ImageDraw.Draw对象</li>
<li>填充随机色块底色</li>
<li>填充文字</li>
<li>模糊</li>
</ul>
<pre><code class="language-python">from PIL import Image, ImageDraw, ImageFont, ImageFilter
import random

# 随机字母:
def rndChar():
    return chr(random.randint(65, 90))
# 随机颜色1:
def rndColor():
    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))
# 随机颜色2:
def rndColor2():
    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))

# 240 x 60:
width = 200 * 4
height = 200
image = Image.new('RGB', (width, height), (255, 255, 255))
# 创建Font对象:
font = ImageFont.truetype(r&quot;H:\APP_data\学习\CODE学习\Python\abc\black.ttf&quot;, 140)
# 创建Draw对象:
draw = ImageDraw.Draw(image)
# 填充每个像素:
for x in range(width):
    for y in range(height):
        draw.point((x, y), fill=rndColor())
# 输出文字:
for t in range(4):
    draw.text((140 * t + 120, 25), rndChar(), font=font, fill=rndColor2())
# 模糊:
image = image.filter(ImageFilter.BLUR)
image.save('code.jpg', 'jpeg')
</code></pre>
<h2 id="requests">requests</h2>
<h2 id="chardet">chardet</h2>
<p>根据搜索同时安装<code>chardet</code>与<code>bs4</code>并使用如下准确性更高 :</p>
<pre><code class="language-python">from bs4 import UnicodeDammit
 
data = '离离原上草，一岁一枯荣'.encode('utf-8')
dammit = UnicodeDammit(data)
print(dammit.unicode_markup)
print(dammit.detector.chardet_encoding)
# 输出
离离原上草，一岁一枯荣
utf-8
</code></pre>
<h1 id="图形界面开始">图形界面开始</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0213-内置模块]]></title>
        <id>https://foreup.github.io/post/0213-nei-zhi-mo-kuai/</id>
        <link href="https://foreup.github.io/post/0213-nei-zhi-mo-kuai/">
        </link>
        <updated>2022-02-13T10:54:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="collections">collections</h2>
<p><strong>namedtuple</strong></p>
<blockquote>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])
&gt;&gt;&gt; p = Point(1, 2)
&gt;&gt;&gt; p.x
&gt;&gt;&gt; 1
&gt;&gt;&gt; p.y
&gt;&gt;&gt; 2
</code></pre>
</blockquote>
<p><strong>deque</strong><br>
支持<code>appendleft()</code>和<code>popleft()</code>;</p>
<blockquote>
<pre><code>&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; q = deque(['a', 'b', 'c'])
&gt;&gt;&gt; q.append('x')
&gt;&gt;&gt; q.appendleft('y')
&gt;&gt;&gt; q
deque(['y', 'a', 'b', 'c', 'x'])
</code></pre>
</blockquote>
<p><strong>defaultdict</strong></p>
<blockquote>
<pre><code>&gt;&gt; from collections import defaultdict
&gt;&gt; dd = defaultdict(lambda: 'N/A')
&gt;&gt; dd['key1'] = 'abc'
&gt;&gt; dd['key1'] # key1存在
   'abc'
&gt;&gt; dd['key2'] # key2不存在，返回默认值
   'N/A'
</code></pre>
</blockquote>
<p><strong>OrderedDict</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; d = dict([('a', 1), ('b', 2), ('c', 3)])
&gt;&gt;&gt; d # dict的Key是无序的
{'a': 1, 'c': 3, 'b': 2}
&gt;&gt;&gt; od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
&gt;&gt;&gt; od # OrderedDict的Key是有序的
OrderedDict([('a', 1), ('b', 2), ('c', 3)])
</code></pre>
<p><strong>ChainMap</strong></p>
<pre><code class="language-python">from collections import ChainMap
import os, argparse

# 构造缺省参数:
defaults = {
    'color': 'red',
    'user': 'guest'
}

# 构造命令行参数:
parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = { k: v for k, v in vars(namespace).items() if v }

# 组合成ChainMap:
combined = ChainMap(command_line_args, os.environ, defaults)

# 打印参数:
print('color=%s' % combined['color'])
print('user=%s' % combined['user'])
</code></pre>
<p><strong>Counter</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; c = Counter()
&gt;&gt;&gt; for ch in 'programming':
...     c[ch] = c[ch] + 1
...
&gt;&gt;&gt; c
Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})
&gt;&gt;&gt; c.update('hello') # 也可以一次性update
&gt;&gt;&gt; c
Counter({'r': 2, 'o': 2, 'g': 2, 'm': 2, 'l': 2, 'p': 1, 'a': 1, 'i': 1, 'n': 1, 'h': 1, 'e': 1})
</code></pre>
<h2 id="base64">base64</h2>
<pre><code class="language-python">&gt;&gt;&gt; import base64
&gt;&gt;&gt; base64.b64encode(b'binary\x00string')
b'YmluYXJ5AHN0cmluZw=='
&gt;&gt;&gt; base64.b64decode(b'YmluYXJ5AHN0cmluZw==')
b'binary\x00string'
&gt;&gt;&gt; base64.b64encode(b'i\xb7\x1d\xfb\xef\xff')
b'abcd++//'
&gt;&gt;&gt; base64.urlsafe_b64encode(b'i\xb7\x1d\xfb\xef\xff')
b'abcd--__'
&gt;&gt;&gt; base64.urlsafe_b64decode('abcd--__')
b'i\xb7\x1d\xfb\xef\xff'
</code></pre>
<h2 id="struct">struct</h2>
<pre><code class="language-python">&gt;&gt;&gt; import struct
&gt;&gt;&gt; struct.pack('&gt;I', 10240099)
b'\x00\x9c@c'
</code></pre>
<p>检查任意文件是否是位图文件，如果是，打印出图片大小和颜色数(只需检测bmp文件)：</p>
<pre><code class="language-python"># -*- coding: utf-8 -*-
import base64, struct
bmp_data = 图片的base64码
def bmp_info(data):
    s = struct.unpack('&lt;ccIIIIIIHH', data[:30])
    if s[0] == b'B' and s[1] == b'M' :
        print ('这是位图')
        return {
            'width': s[6],
            'height': s[7],
            'color': s[9]
        }
</code></pre>
<p><strong>hashlib/哈希算法</strong><br>
用户密码“加盐”存储MD5的作用与方法；</p>
<pre><code class="language-python">import hashlib

md5 = hashlib.md5()
md5.update('how to use md5 in python hashlib?'.encode('utf-8'))
print(md5.hexdigest())
sha1 = hashlib.sha1()
sha1.update('how to use sha1 in '.encode('utf-8'))
sha1.update('python hashlib?'.encode('utf-8'))
print(sha1.hexdigest())
</code></pre>
<p><strong>hmac</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; import hmac
&gt;&gt;&gt; message = b'Hello, world!'
&gt;&gt;&gt; key = b'secret'
&gt;&gt;&gt; h = hmac.new(key, message, digestmod='MD5')
&gt;&gt;&gt; # 如果消息很长，可以多次调用h.update(msg)
&gt;&gt;&gt; h.hexdigest()
'fa4ee7d173f2d97ee79022d1a7355bcf'
</code></pre>
<p><strong>itertools</strong><br>
<code>count()</code>创建一个无限的迭代器，打印出自然数序列:</p>
<pre><code class="language-python">&gt;&gt;&gt; import itertools
&gt;&gt;&gt; natuals = itertools.count(1)
&gt;&gt;&gt; for n in natuals:
...     print(n)
...
1
2
3
...
</code></pre>
<p><code>cycle()</code>会把传入的一个序列无限重复下去：</p>
<pre><code class="language-python">&gt;&gt;&gt; import itertools
&gt;&gt;&gt; cs = itertools.cycle('ABC') # 注意字符串也是序列的一种
&gt;&gt;&gt; for c in cs:
...     print(c)
...
'A'
'B'
'C'
'A'
'B'
'C'
...
</code></pre>
<p><code>repeat()</code>负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数：</p>
<pre><code class="language-python">&gt;&gt;&gt; ns = itertools.repeat('A', 3)
&gt;&gt;&gt; for n in ns:
...     print(n)
...
A
A
A
</code></pre>
<p><code>takewhile()</code>等函数根据条件判断来截取出一个有限的序列：</p>
<pre><code class="language-python">&gt;&gt;&gt; natuals = itertools.count(1)
&gt;&gt;&gt; ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)
&gt;&gt;&gt; list(ns)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>
<p><strong>chain()</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; for c in itertools.chain('ABC', 'XYZ'):
...     print(c)
# 迭代效果：'A' 'B' 'C' 'X' 'Y' 'Z'
</code></pre>
<p><strong>groupby()</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; for key, group in itertools.groupby('AAABBBCCAAA'):
...     print(key, list(group))
...
A ['A', 'A', 'A']
B ['B', 'B', 'B']
C ['C', 'C']
A ['A', 'A', 'A']
</code></pre>
<p>忽略大小写分组:</p>
<pre><code class="language-python">&gt;&gt;&gt; for key, group in itertools.groupby('AaaBBbcCAAa', lambda c: c.upper()):
...     print(key, list(group))
...
A ['A', 'a', 'a']
B ['B', 'B', 'b']
C ['c', 'C']
A ['A', 'A', 'a']
</code></pre>
<p><strong>contextlib</strong><br>
<code>from contextlib import contextmanager</code> 连接上下文用来使用<code>with</code>语句:</p>
<pre><code class="language-python">@contextmanager
def tag(name):
    print(&quot;&lt;%s&gt;&quot; % name)
    yield
    print(&quot;&lt;/%s&gt;&quot; % name)

with tag(&quot;h1&quot;):
    print(&quot;hello&quot;)
    print(&quot;world&quot;)
#结果
&lt;h1&gt;
hello
world
&lt;/h1&gt;
</code></pre>
<p>用<code>closing()</code>来把该对象变为上下文对象:</p>
<pre><code class="language-python">from contextlib import closing
from urllib.request import urlopen

with closing(urlopen('https://www.python.org')) as page:
    for line in page:
        print(line)
</code></pre>
<p><strong>urllib</strong><br>
<code>urllib</code>的<code>request</code>模块</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0212-爬取图片-随想]]></title>
        <id>https://foreup.github.io/post/0212-pa-qu-tu-pian-sui-xiang/</id>
        <link href="https://foreup.github.io/post/0212-pa-qu-tu-pian-sui-xiang/">
        </link>
        <updated>2022-02-12T11:49:35.000Z</updated>
        <content type="html"><![CDATA[<p>使用BeautifulSoup与requests爬取美图:<br>
<code>r = requests.get(url, headers=headers, timeout = 30)</code>以请求头访问指定的URL；<br>
<code>r.encoding = r.apparent_encoding</code>网页的编码方式；<br>
<code>return r.text</code>返回网页的文字；</p>
<pre><code class="language-python">soup = BeautifulSoup(html, 'lxml')
    img_ul = soup.find_all('img', {&quot;class&quot;: &quot;progressive__img progressive--not-loaded&quot;})
</code></pre>
<p>上面代码用来选择网页的元素；</p>
<pre><code class="language-python">with open('路径\img\%s' % (image_name), 'wb') as f: #不知为啥必须是绝对路径且不能访问未创建的文件夹
		for chunk in r.iter_content(chunk_size=128): #将网页内容可迭代
				f.write(chunk)
</code></pre>
<p>上面用来写入图片；</p>
<pre><code class="language-python">import requests
from bs4 import BeautifulSoup
import os

def gethtmltext(url):
    try:
        headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) '
                        'Chrome/51.0.2704.63 Safari/537.36'}
        r = requests.get(url, headers=headers, timeout = 30)
        r.raise_for_status()
        r.encoding = r.apparent_encoding
        return r.text
    except:
        print (&quot;错误&quot;)
for i in range(11, 21):
    URL = &quot;https://bing.wilii.cn/index.asp&quot;+(&quot;?page=%s&quot; % i)
    html = gethtmltext(URL)
    soup = BeautifulSoup(html, 'lxml')
    img_ul = soup.find_all('img', {&quot;class&quot;: &quot;progressive__img progressive--not-loaded&quot;})
    #print (soup) #打印网页源码

    for img in img_ul:
        url = &quot;https://bing.wilii.cn&quot;+img['src']
        print (url)
        r = requests.get(url, stream=True)
        image_name = url.split('/')[-1]
        #image_name = image_name0.split('?')[0]
        with open('F:\MIUI_data\python_test\img\%s' % (image_name), 'wb') as f:
            for chunk in r.iter_content(chunk_size=128):
                f.write(chunk)
        print('Saved %s' % image_name) 
</code></pre>
<h2 id="随想">随想</h2>
<ul>
<li>文件批量重命名脚本<br>
<code>list</code>与<code>str</code>的相互转化；<br>
<code>list</code>的截取；</li>
<li>文件复制<br>
<code>shutil.copyfile</code><br>
<code>shutil.coytree</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0211-进程线程-爬虫基础]]></title>
        <id>https://foreup.github.io/post/0211-jin-cheng-xian-cheng-pa-chong-ji-chu/</id>
        <link href="https://foreup.github.io/post/0211-jin-cheng-xian-cheng-pa-chong-ji-chu/">
        </link>
        <updated>2022-02-11T11:36:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="进程和线程">进程和线程</h1>
<h2 id="多进程">多进程</h2>
<h3 id="multiprocessing">multiprocessing</h3>
<p><strong><code>multiprocessing</code></strong> 模块提供了一个 <code>Process</code> 类来代表一个进程对象.<br>
<code>join()</code>方法可以等待子进程结束后再继续往下运行，或者说说将进程加入主进程，通常用于进程间的同步。</p>
<pre><code class="language-python">from multiprocessing import Process
import os

# 子进程要执行的代码
def run_proc(name):
    print('Run child process %s (%s)...' % (name, os.getpid()))

if __name__=='__main__':
    print('Parent process %s.' % os.getpid())
    p = Process(target=run_proc, args=('test',))
    print('Child process will start.')
    p.start()
    p.join()
    print('Child process end.')
#结果
Parent process 928.
Child process will start.
Run child process test (929)...
Process end.
</code></pre>
<h2 id="多进程-2">多进程</h2>
<p><code>threading</code>高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。<br>
启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p>
<pre><code class="language-python">import time, threading

# 新线程执行的代码:
def loop():
    print('thread %s is running...' % threading.current_thread().name)
    n = 0
    while n &lt; 5:
        n = n + 1
        print('thread %s &gt;&gt;&gt; %s' % (threading.current_thread().name, n))
        time.sleep(1)
    print('thread %s ended.' % threading.current_thread().name)

print('thread %s is running...' % threading.current_thread().name)
t = threading.Thread(target=loop, name='LoopThread')
t.start()
t.join()
print('thread %s ended.' % threading.current_thread().name)
#执行结果
thread MainThread is running...
thread LoopThread is running...
thread LoopThread &gt;&gt;&gt; 1
thread LoopThread &gt;&gt;&gt; 2
thread LoopThread &gt;&gt;&gt; 3
thread LoopThread &gt;&gt;&gt; 4
thread LoopThread &gt;&gt;&gt; 5
thread LoopThread ended.
thread MainThread ended.
</code></pre>
<h3 id="lock">Lock</h3>
<p>多进程的变量各自独立互不影响，多线程的变量相互共享，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。<br>
<strong>例子：</strong></p>
<pre><code class="language-python">import time, threading

# 假定这是你的银行存款:
balance = 0

def change_it(n):
    # 先存后取，结果应该为0:
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(2000000):
        change_it(n)

t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print(balance)
#结果
3
</code></pre>
<p>t1、t2交替执行时，只要循环次数足够多，<code>balance</code>的结果就不一定是<code>0</code>了。<br>
创建一个锁就是通过<code>threading.Lock()</code>来实现：</p>
<pre><code class="language-python">balance = 0
lock = threading.Lock()

def run_thread(n):
    for i in range(100000):
        # 先要获取锁:
        lock.acquire()
        try:
            # 放心地改吧:
            change_it(n)
        finally:
            # 改完了一定要释放锁:
            lock.release()
</code></pre>
<p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程，所以使用<code>try....finally....</code>确保释放锁。</p>
<h2 id="threadlocal">ThreadLocal</h2>
<p>全局变量<code>local_school</code>就是一个<code>ThreadLocal</code>对象，每个<code>Thread</code>对它都可以读写<code>student</code>属性，但互不影响；<br>
每个属性如<code>local_school.student</code>都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，<code>ThreadLocal</code>内部会处理；<br>
可以理解为全局变量<code>local_school</code>是一个<code>dict</code>，不但可以用<code>local_school.student</code>，还可以绑定其他变量，如<code>local_school.teacher</code>等等：</p>
<pre><code class="language-python">import threading
    
# 创建全局ThreadLocal对象:
local_school = threading.local()

def process_student():
    # 获取当前线程关联的student:
    std = local_school.student
    print('Hello, %s (in %s)' % (std, threading.current_thread().name))

def process_thread(name):
    # 绑定ThreadLocal的student:
    local_school.student = name
    process_student()

t1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')
t2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')
t1.start()
t2.start()
t1.join()
t2.join()
#结果：
Hello, Alice (in Thread-A)
Hello, Bob (in Thread-B)
</code></pre>
<h2 id="分布式进程">分布式进程</h2>
<p>利用<code>managers</code>模块分装<code>queue</code>，<code>register</code>到网络上并设置<code>端口</code>与验证<code>authkey</code>，具体见下：<br>
两个<code>.py</code>文件，<code>master.py</code>和<code>worker.py</code>;<br>
下列代码可能在Windows下有错误，修改见 <strong><a href="https://www.liaoxuefeng.com/discuss/969955749132672/1441664361037857">廖雪峰网站评论区</a></strong></p>
<pre><code class="language-python"># task_master.py

import random, time, queue
from multiprocessing.managers import BaseManager

# 发送任务的队列:
task_queue = queue.Queue()
# 接收结果的队列:
result_queue = queue.Queue()

# 从BaseManager继承的QueueManager:
class QueueManager(BaseManager):
    pass

# 把两个Queue都注册到网络上, callable参数关联了Queue对象:
QueueManager.register('get_task_queue', callable=lambda: task_queue)
QueueManager.register('get_result_queue', callable=lambda: result_queue)
# 绑定端口5000, 设置验证码'abc':
manager = QueueManager(address=('', 5000), authkey=b'abc')
# 启动Queue:
manager.start()
# 获得通过网络访问的Queue对象:
task = manager.get_task_queue()
result = manager.get_result_queue()
# 放几个任务进去:
for i in range(10):
    n = random.randint(0, 10000)
    print('Put task %d...' % n)
    task.put(n)
# 从result队列读取结果:
print('Try get results...')
for i in range(10):
    r = result.get(timeout=10)
    print('Result: %s' % r)
# 关闭:
manager.shutdown()
print('master exit.'
</code></pre>
<p>添加任务到<code>Queue</code>不可以直接对原始的<code>task_queue</code>进行操作，那样就绕过了<code>QueueManager</code>的封装，必须通过<code>manager.get_task_queue()</code>获得的<code>Queue</code>接口添加。</p>
<pre><code class="language-python"># task_worker.py

import time, sys, queue
from multiprocessing.managers import BaseManager

# 创建类似的QueueManager:
class QueueManager(BaseManager):
    pass

# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:
QueueManager.register('get_task_queue')
QueueManager.register('get_result_queue')

# 连接到服务器，也就是运行task_master.py的机器:
server_addr = '127.0.0.1'
print('Connect to server %s...' % server_addr)
# 端口和验证码注意保持与task_master.py设置的完全一致:
m = QueueManager(address=(server_addr, 5000), authkey=b'abc')
# 从网络连接:
m.connect()
# 获取Queue的对象:
task = m.get_task_queue()
result = m.get_result_queue()
# 从task队列取任务,并把结果写入result队列:
for i in range(10):
    try:
        n = task.get(timeout=1)
        print('run task %d * %d...' % (n, n))
        r = '%d * %d = %d' % (n, n, n*n)
        time.sleep(1)
        result.put(r)
    except Queue.Empty: #或者是queue.Empty
        print('task queue is empty.')
# 处理结束:
print('worker exit.')
</code></pre>
<p><strong>结果</strong><br>
先启动task_master.py服务进程：</p>
<pre><code class="language-python">$ python3 task_master.py 
Put task 3411...
Put task 1605...
Put task 1398...
Put task 4729...
Put task 5300...
Put task 7471...
Put task 68...
Put task 4219...
Put task 339...
Put task 7866...
Try get results...
</code></pre>
<p><code>task_master.py</code>进程发送完任务后，开始等待<code>result</code>队列的结果。现在启动<code>task_worker.py</code>进程：</p>
<pre><code class="language-python">$ python3 task_worker.py
Connect to server 127.0.0.1...
run task 3411 * 3411...
run task 1605 * 1605...
run task 1398 * 1398...
run task 4729 * 4729...
run task 5300 * 5300...
run task 7471 * 7471...
run task 68 * 68...
run task 4219 * 4219...
run task 339 * 339...
run task 7866 * 7866...
worker exit.
</code></pre>
<p><code>task_worker.py</code>进程结束，在<code>task_master.py</code>进程中会继续打印出结果：</p>
<pre><code class="language-python">Result: 3411 * 3411 = 11634921
Result: 1605 * 1605 = 2576025
Result: 1398 * 1398 = 1954404
Result: 4729 * 4729 = 22363441
Result: 5300 * 5300 = 28090000
Result: 7471 * 7471 = 55815841
Result: 68 * 68 = 4624
Result: 4219 * 4219 = 17799961
Result: 339 * 339 = 114921
Result: 7866 * 7866 = 61873956
</code></pre>
<h1 id="莫烦爬虫">莫烦爬虫</h1>
<p><strong>打开网页</strong></p>
<pre><code class="language-python">from urllib.request import urlopen

# if has Chinese, apply decode()
html = urlopen(
    &quot;https://mofanpy.com/static/scraping/basic-structure.html&quot;
).read().decode('utf-8')
print(html)
</code></pre>
<p><strong>BeautifulSoup</strong><br>
利用beautifulsoup<strong>爬取百度百科</strong>词条:<br>
重点:</p>
<pre><code class="language-python">#注意结果的形式及匹配方式
soup.find_all('a', {&quot;target&quot;:&quot;_blank&quot;, &quot;href&quot;:re.compile(&quot;/item/(%.+)+$&quot;)}) 
soup.find('h1').get_text()
#注意随机排序与获取一个例子
sublink.append(random.sample(nexturl, 1)[0]['href'])
</code></pre>
<p>代码:</p>
<pre><code class="language-python">from urllib.request import urlopen
from bs4 import BeautifulSoup
import re
import random

sublink = [&quot;/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/5162711&quot;]
mainlink= &quot;https://baike.baidu.com&quot;

for i in range(20):
    alink = mainlink + sublink[-1]
    html = urlopen(alink).read().decode('utf-8')
    soup = BeautifulSoup(html, features='lxml')
    print (soup.find('h1').get_text(), '   url:', sublink[-1])
    nexturl = soup.find_all('a', {&quot;target&quot;:&quot;_blank&quot;, &quot;href&quot;:re.compile(&quot;/item/(%.+)+$&quot;)})
    #print (nexturl)
    if len(nexturl)!=0 :
        sublink.append(random.sample(nexturl, 1)[0]['href'])
    else :
        sublink.pop()

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0210-文件操作]]></title>
        <id>https://foreup.github.io/post/0210-wen-jian-cao-zuo/</id>
        <link href="https://foreup.github.io/post/0210-wen-jian-cao-zuo/">
        </link>
        <updated>2022-02-10T09:46:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="io编程">IO编程</h1>
<p>本章主要讲同步IO,异步IO太复杂,后续涉及到服务端再讲.</p>
<h2 id="文件读写">文件读写</h2>
<p><strong>读文件</strong><br>
<code>open()</code> 函数, <code>f.close()</code> 关闭文件;<br>
调用<code>read()</code>会一次性读取文件的全部内容, <code>read(size)</code>读取<code>size</code>个字符/字节的内容.<br>
<code>readline()</code>可以每次<strong>读取一行</strong>内容，调用<code>readlines()</code>一次读取所有内容并<strong>按行返回list</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; with open('ABC.txt', 'r') as fname :
&gt;&gt;&gt; 		str = fname.read()
&gt;&gt;&gt; f = open('/Users/michael/test.jpg', 'rb') #以二进制打开, 打开文本可以用decode解码为字符串
&gt;&gt;&gt; f.read()
b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节
for line in f.readlines():
    print(line.strip()) # strip参数为空,把末尾的'\n'或空格删掉
</code></pre>
<p><strong>写文件</strong><br>
调用<code>open()</code>函数时，传入标识符<code>'w'</code>或者<code>'wb'</code>表示写文本文件或写二进制文件：新建或删除存在的内容.<br>
追加内容用标识符:<code>a</code>.<br>
<strong>StringIO和BytesIO</strong></p>
<ul>
<li><code>tell</code> 方法获取当前文件读取指针的位置</li>
<li><code>seek</code> 方法，用于移动文件读写指针到指定位置,有两个参数，第一个<strong>offset</strong>: 偏移量，需要向前或向后的字节数，<strong>正为向后，负为向前</strong>；第二个<strong>whence</strong>: 可选值，默认为<code>0</code>，表示文件<strong>开头</strong>，<code>1</code>表示相对于<strong>当前</strong>的位置，<code>2</code>表示文件<strong>末尾</strong></li>
<li>用<code>seek</code>方法时，需注意，如果你打开的文件没有用<b><code>'b'</code></b>的方式打开，则<code>offset</code>无法使用<strong>负值</strong>哦</li>
</ul>
<pre><code class="language-python"># stringIO 比如说，这时候，你需要对获取到的数据进行操作，但是你并不想把数据写到本地硬盘上，这时候你就可以用stringIO
from io import StringIO
from io import BytesIO
def outputstring():
    return 'string \nfrom \noutputstring \nfunction'

s = outputstring()

# 将函数返回的数据在内存中读
sio = StringIO(s)
# 可以用StringIO本身的方法
print(sio.getvalue())
# 也可以用file-like object的方法
s = sio.readlines()
for i in s:
    print(i.strip())


# 将函数返回的数据在内存中写
sio = StringIO()
sio.write(s)
# 可以用StringIO本身的方法查看
s=sio.getvalue()
print(s)

# 如果你用file-like object的方法查看的时候，你会发现数据为空
sio = StringIO()
sio.write(s)
for i in sio.readlines():
    print(i.strip())

# 这时候我们需要修改下文件的指针位置
# 我们发现可以打印出内容了
sio = StringIO()
sio.write(s)
sio.seek(0,0)
print(sio.tell())
for i in sio.readlines():
    print(i.strip())

# 上面涉及到了两个方法seek 和 tell

# stringIO 只能操作str，如果要操作二进制数据，就需要用到BytesIO
# 上面的sio无法用seek从当前位置向前移动，这时候，我们用'b'的方式写入数据，就可以向前移动了
bio = BytesIO()
bio.write(s.encode('utf-8'))
print(bio.getvalue())
bio.seek(-36,1)
print(bio.tell())
for i in bio.readlines():
    print(i.strip())
</code></pre>
<h2 id="操作文件与目录">操作文件与目录</h2>
<p><code>os.chdir(file_path)</code><br>
进入file_path路径;<br>
<code>os.path.abspath('.')</code><br>
当前位置的绝对路径<br>
<code>os.path.join(pwd,x)</code><br>
合并路径<br>
<code>os.listdir(pwd)</code><br>
列出当前路径所有文件及目录(不包括子目录)<br>
<code>os.path.isfile(os.path.join(pwd,x))</code><br>
判断括号内的路径是否为文件<br>
<code>os.path.isdir(os.path.join(pwd,x))</code><br>
判断括号内的路径是否为目录<br>
<code>shutil</code>模块提供了<code>copyfile()</code>的函数</p>
<pre><code class="language-python">&gt;&gt;&gt; os.path.split('/Users/michael/testdir/file.txt')
('/Users/michael/testdir', 'file.txt')
&gt;&gt;&gt; os.path.splitext('/path/to/file.txt') #获得文件拓展名
('/path/to/file', '.txt')

</code></pre>
<p><strong>查找</strong>当前目录及子目录的指定文件名:</p>
<pre><code class="language-python">import os

def findfile(s, file_path):
    #进入当前目录
    os.chdir(file_path)
    #查找当前目录包含输入字符串的文件
    L = [x for x in os.listdir('.') if os.path.isfile(x)]
    for x in L:
        #查找是否包含s，包含返回开始s的下标，不包含返回-1
        if x.find(s)!=-1:
            print(os.path.join(file_path,x))
        else:
            pass
    #查找各目录中是否包含输入字符串的文件
    Y = [x for x in os.listdir('.') if os.path.isdir(x)]
    for x in Y:
        file_path2=os.path.join(file_path,x)
        findfile(s,file_path2)

def main():
    #path = input('请输入绝对路径：')
    path = os.path.abspath('.')
    s = input('请输入要查找的字符串：')
    result = findfile(s, path)
    if result == None :
        print ('没找到或查找结束！')

if __name__ == '__main__':
    main()
</code></pre>
<h2 id="序列化">序列化</h2>
<p><strong>pickle</strong><br>
<code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>;<br>
<code>pickle.loads()</code>方法反序列化出对象;<br>
<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>即写入文件;<br>
<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象.</p>
<pre><code class="language-python">&gt;&gt;&gt; import pickle
&gt;&gt;&gt; d = dict(name='Bob', age=20, score=88)
&gt;&gt;&gt; pickle.dumps(d)
b'\x80\x03}q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.'
&gt;&gt;&gt; f = open('dump.txt', 'wb')
&gt;&gt;&gt; pickle.dump(d, f)
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; f = open('dump.txt', 'rb')
&gt;&gt;&gt; d = pickle.load(f)
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; d
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<p><strong>JSON</strong></p>
<table>
<thead>
<tr>
<th>JSON类型</th>
<th>Python类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>{}</td>
<td>dict</td>
</tr>
<tr>
<td>[]</td>
<td>list</td>
</tr>
<tr>
<td>&quot;string&quot;</td>
<td>str</td>
</tr>
<tr>
<td>1234.56</td>
<td>int或float</td>
</tr>
<tr>
<td>true/false</td>
<td>True/False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><code>json</code>模块，<code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的<code>JSON</code>；类似的，<code>dump()</code>方法可以直接把<code>JSON</code>写入一个<code>file-like Object</code>。</p>
<pre><code class="language-python">&gt;&gt;&gt; import json
&gt;&gt;&gt; d = dict(name='Bob', age=20, score=88)
&gt;&gt;&gt; json.dumps(d)
'{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
&gt;&gt;&gt; json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
&gt;&gt;&gt; json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<p><strong><code>class</code></strong> 转为json对象:<br>
<code>dumps()</code>方法的<code>default</code>参数可以定义将<code>class</code>转为<code>dict</code>的函数;</p>
<pre><code class="language-python">import json

class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score
s = Student('Bob', 20, 88)

def student2dict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }
&gt;&gt;&gt; print(json.dumps(s, default=student2dict))
{&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}
</code></pre>
<p>通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量; 少数例外，比如定义了<code>__slots__</code>的<code>class</code>。</p>
<pre><code class="language-python">print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre>
<p><code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p>
<pre><code class="language-python">def dict2student(d):
    return Student(d['name'], d['age'], d['score'])

&gt;&gt;&gt; json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))
&lt;__main__.Student object at 0x10cd3c190&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0209-对象高级编程-错误测试]]></title>
        <id>https://foreup.github.io/post/0209-dui-xiang-gao-ji-bian-cheng-cuo-wu-ce-shi/</id>
        <link href="https://foreup.github.io/post/0209-dui-xiang-gao-ji-bian-cheng-cuo-wu-ce-shi/">
        </link>
        <updated>2022-02-09T11:42:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用__slots_">使用__slots_</h2>
<p>限制实例可添加的属性, 但对当前类中的<code>__slots__</code>对子类无作用:</p>
<pre><code class="language-python">class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
&gt;&gt;&gt; s = Student() # 创建新的实例
&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'
&gt;&gt;&gt; s.age = 25 # 绑定属性'age'
&gt;&gt;&gt; s.score = 99 # 绑定属性'score'--报错
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'score'
#对子类不起作用
&gt;&gt;&gt; class GraduateStudent(Student):
...     pass
...
&gt;&gt;&gt; g = GraduateStudent()
&gt;&gt;&gt; g.score = 9999 #不报错
</code></pre>
<h2 id="使用property">使用@property</h2>
<p><code>@property</code>默认只赋予<code>getter</code>属性, 如需<code>setter</code>需要用到<code>属性名.setter</code>:<br>
<code>@property</code>给一个Screen对象加上<code>width</code>和<code>height</code>属性，以及一个只读属性<code>resolution</code>：</p>
<pre><code class="language-python">class Screen(object):
    @property
    def width(self):
        return self._width
    @property
    def height(self):
        return self._height
    @property
    def resolution(self):
        return self._width*self._height

    @height.setter
    def height(self, x):
        if isinstance(x, int):
            self._height = x
        else:
            raise ValueError('check your value')
    @width.setter
    def width(self, x):
        if isinstance(x, int):
            self._width= x
        else:
            raise ValueError('check your value')
# 测试:
s = Screen()
s.width = 1024
s.height = 768
print('resolution =', s.resolution)
if s.resolution == 786432:
    print('测试通过!')
else:
    print('测试失败!')
</code></pre>
<h2 id="多重继承">多重继承</h2>
<p>或者叫<strong>多继承</strong>，与java的多重继承区分。<br>
实例方法的调用顺序按照<b><a href="https://www.jianshu.com/p/c9a0b055947b">拓扑序列</a></b>的展开顺序。<br>
类的继承关系通常主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为<b><code>MixIn</code></b>。</p>
<h2 id="定制类">定制类</h2>
<p><b> __str__</b><br>
通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的，所以，有个偷懒的写法：</p>
<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name=%s)' % self.name
    __repr__ = __str__
</code></pre>
<p><b>__iter__</b><br>
如果一个类想被用于<code>for ... in</code>循环, 就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。</p>
<pre><code class="language-python">class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b
    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己
    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
	
#调用
&gt;&gt;&gt; for n in Fib():
...     print(n)
...
1
1
2
3
5
...
46368
75025
</code></pre>
<p><b>__getitem__</b></p>
<p><b>__getattr__</b><br>
只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如<code>name</code>，不会在<code>__getattr__</code>中查找。</p>
<p><b>__call__</b></p>
<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)
&gt;&gt;&gt; s = Student('Michael')
&gt;&gt;&gt; s() # self参数不要传入
My name is Michael.
</code></pre>
<p><code>__call__()</code>还可以定义参数;<br>
可以把对象看成函数，把函数看成对象，因为两者之间本没有根本的区别；<br>
<code>callable()</code>函数，判断一个对象是否是“可调用”对象。</p>
<h2 id="枚举类">枚举类</h2>
<p><code>from enum import Enum</code>:</p>
<pre><code class="language-python">from enum import Enum
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
for name, member in Month.__members__.items():
    print(name, '=&gt;', member, ',', member.value)
</code></pre>
<p>把<code>Student</code>的<code>gender</code>属性改造为枚举类型，可以避免使用字符串：</p>
<pre><code class="language-python"># -*- coding: utf-8 -*-
from enum import Enum, unique
class Gender(Enum):
    Male = 0
    Female = 1
class Student(object):
    def __init__(self, name, gender):
        self.name = name
        self.gender = Gender(gender)
# 测试:
bart = Student('Bart', Gender.Male)
if bart.gender == Gender.Male:
    print('测试通过!')
else:
    print('测试失败!')
</code></pre>
<h2 id="元类暂时跳过">元类——暂时跳过</h2>
<p>网站说以后用不到,以后在再学吧</p>
<h1 id="错误调试与测试">错误调试与测试</h1>
<h2 id="错误处理">错误处理</h2>
<pre><code class="language-python">try:
    print('try...')
    r = 10 / int('2')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
else:
    print('no error!')
finally:
    print('finally...')
print('END')
</code></pre>
<p><strong>抛出错误</strong></p>
<pre><code class="language-python"># err_raise.py
class FooError(ValueError):
    pass

def foo(s):
    n = int(s)
    if n==0:
        raise FooError('invalid value: %s' % s)
    return 10 / n

foo('0')
</code></pre>
<h2 id="调试">调试</h2>
<p><strong>assert</strong><br>
<code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则抛出<code>AssertionError</code><br>
<strong>logging</strong></p>
<pre><code class="language-python">import logging
logging.basicConfig(level=logging.INFO) #指定记录的级别

s = '0'
n = int(s)
logging.info('n = %d' % n)
print(10 / n)
#输出
$ python err.py
INFO:root:n = 0
Traceback (most recent call last):
  File &quot;err.py&quot;, line 8, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero
</code></pre>
<p>允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>不起作用; 指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>不起作用.<br>
<strong>pdb</strong><br>
以参数<code>-m pdb</code>启动后，<code>pdb</code>定位到下一步要执行的代码<code>-&gt; s = '0'</code>。<br>
输入命令<code>l</code>:  <code>(Pdb) l</code>  来查看代码;<br>
<code>n</code>:  可以单步执行代码;<br>
输入命令  <code>p</code>  变量名来查看变量;<br>
<code>q</code>结束调试</p>
<pre><code class="language-python">$ python -m pdb err.py
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()
-&gt; s = '0'
</code></pre>
<p><code>pdb.set_trace()</code>执行到此行代码进入<code>pdb</code>调试模式.</p>
<h2 id="单元测试">单元测试</h2>
<p>读取实例属性: <code>实例名.属性</code> 记住<code>.</code>的作用是获取属性;<br>
编写一个Dict类，这个类的行为和dict一致，但是可以通过属性来访问，用起来就像下面这样：</p>
<pre><code class="language-python">&gt;&gt;&gt; d = Dict(a=1, b=2)
&gt;&gt;&gt; d['a']
1
&gt;&gt;&gt; d.a #通过属性访问
1
</code></pre>
<p><code>mydict.py</code>代码如下：</p>
<pre><code class="language-python">class Dict(dict):

    def __init__(self, **kw):
        super().__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;'Dict' object has no attribute '%s'&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value
</code></pre>
<p>测试单元: <code>unittest</code>模块，编写<code>mydict_test.py</code></p>
<pre><code class="language-python">import unittest

from mydict import Dict

class TestDict(unittest.TestCase):

    def test_init(self):
        d = Dict(a=1, b='test')
        self.assertEqual(d.a, 1)
        self.assertEqual(d.b, 'test')
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d['key'] = 'value'
        self.assertEqual(d.key, 'value')

    def test_attr(self):
        d = Dict()
        d.key = 'value'
        self.assertTrue('key' in d) #注意
        self.assertEqual(d['key'], 'value') #注意

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError): #注意
            value = d['empty']

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError):
            value = d.empty
</code></pre>
<p>运行单元测试:</p>
<pre><code class="language-python">#在mydict_test.py的最后加上两行代码：
if __name__ == '__main__':
    unittest.main()
#然后当做正常的python脚本运行：
$ python mydict_test.py
#推荐方法:
#通过参数-m unittest直接运行单元测试：
$ python -m unittest mydict_test
.....
----------------------------------------------------------------------
Ran 5 tests in 0.000s

OK
</code></pre>
<h2 id="文档测试">文档测试</h2>
<p>上节课的例子用文档测试:</p>
<pre><code class="language-python"># mydict2.py
class Dict(dict):
    '''
    Simple dict but also support access as x.y style.

    &gt;&gt;&gt; d1 = Dict()
    &gt;&gt;&gt; d1['x'] = 100
    &gt;&gt;&gt; d1.x
    100
    &gt;&gt;&gt; d1.y = 200
    &gt;&gt;&gt; d1['y']
    200
    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c='3')
    &gt;&gt;&gt; d2.c
    '3'
    &gt;&gt;&gt; d2['empty']
    Traceback (most recent call last):
        ...
    KeyError: 'empty'
    &gt;&gt;&gt; d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: 'Dict' object has no attribute 'empty'
    '''
    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;'Dict' object has no attribute '%s'&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value

if __name__=='__main__':  #确保只在测试环境运行文档测试, 在引用模块不运行.
    import doctest
    doctest.testmod()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0208-函数-对象编程]]></title>
        <id>https://foreup.github.io/post/0208-han-shu-dui-xiang-bian-cheng/</id>
        <link href="https://foreup.github.io/post/0208-han-shu-dui-xiang-bian-cheng/">
        </link>
        <updated>2022-02-08T11:26:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="返回函数">返回函数</h2>
<p>类似js的闭包;<br>
例子1:</p>
<pre><code class="language-Python">def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
</code></pre>
<p>计数器:<br>
在<code>fn()</code>函数内部加一个<code>nonlocal x</code>的声明, 解释器把fn()的x看作外层函数的局部变量，它已经被初始化了，可以正确计算<code>x+1</code>.</p>
<pre><code class="language-Python">def createCounter():
    x = 0
    def counter():
        nonlocal x  #去掉会报错
        x = x +1
        return x
    return counter
f = createCounter()
print(f()) # 1
print(f()) # 2
print(f()) # 3
print(f()) # 4
</code></pre>
<h2 id="匿名函数">匿名函数</h2>
<p><code>lambda</code> 定义了匿名函数<br>
过滤偶数:<br>
<code>filter</code> 中的函数参数没有<code>()</code>与<code>参数</code></p>
<pre><code class="language-Python"># -*- coding: utf-8 -*-
def is_odd(n):
    return n % 2 == 1
L = list(filter(is_odd, range(1, 20))) #is_odd不需要写参数
#通过匿名函数
L = list(filter(lambda x : x % 2 == 1, range(1, 20)))
</code></pre>
<h2 id="装饰器">装饰器</h2>
<p><code>wrapper()</code> 函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。<br>
<code>wrapper.__name__ = func.__name__</code>等同于Python内置的<code>@functools.wraps(func)</code><br>
设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间：</p>
<pre><code class="language-Python"># -*- coding: utf-8 -*-
import time, functools

def metric(fn):
    @functools.wraps(fn)
    def wrapper(*args,**kw):
        startTime = time.time()
        result = fn(*args,**kw)
        endTime = time.time()
        excuteTime = 1000 * (endTime- startTime)
        print('%s executed in %s ms' % (fn.__name__, excuteTime))
        return result
    return wrapper

# 测试
@metric
def fast(x, y):
    time.sleep(0.0012)
    return x + y;
@metric
def slow(x, y, z):
    time.sleep(0.1234)
    return x * y * z;

f = fast(11, 22)
s = slow(11, 22, 33)
##输出
fast executed in 1.293182373046875 ms
slow executed in 123.56829643249512 ms
</code></pre>
<p><strong>带参数的decorator</strong></p>
<pre><code class="language-Python">import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

#定义函数
@log('execute')
def now():
    print('2015-3-25')
#执行结果
&gt;&gt;&gt; now()
execute now():
2015-3-25
</code></pre>
<h2 id="偏函数">偏函数</h2>
<p><code>int()</code> 函数提供 <code>base</code> 参数，默认值为 <code>10</code>。如果传入 <code>base</code> 参数，就可以做N进制的转换：</p>
<pre><code class="language-Python">&gt;&gt;&gt; int('12345', base=8)
5349
&gt;&gt;&gt; int('12345', 16)
74565
</code></pre>
<p>利用偏函数固定参数:<br>
<code>functools.partial</code> 固定函数的某个参数, 实现简化函数调用</p>
<pre><code class="language-Python">&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2('1000000')
64
&gt;&gt;&gt; int2('1010101')
85
</code></pre>
<h2 id="模块">模块</h2>
<p>以内建的 <code>sys</code> 模块为例:</p>
<pre><code class="language-Python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' a test module '

__author__ = 'Michael Liao'

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print('Hello, world!')
    elif len(args)==2:
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

if __name__=='__main__':
    test()
</code></pre>
<p><strong>作用域</strong><br>
类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；<br>
Python并没有一种方法可以完全限制访问<code>private</code>函数或变量，但是，从编程习惯上不应该引用<code>private</code>函数或变量。<br>
private函数的作用示例:</p>
<pre><code class="language-Python">def _private_1(name):
    return 'Hello, %s' % name

def _private_2(name):
    return 'Hi, %s' % name

def greeting(name):
    if len(name) &gt; 3:
        return _private_1(name)
    else:
        return _private_2(name)
</code></pre>
<h1 id="面向对象编程">面向对象编程</h1>
<h2 id="类和实例">类和实例</h2>
<p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量<code>self</code>，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。<br>
定义类:</p>
<pre><code class="language-Python">class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score
</code></pre>
<p><code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p>
<pre><code class="language-Python">&gt;&gt;&gt; bart = Student('Bart Simpson', 59)
&gt;&gt;&gt; bart.name
'Bart Simpson'
&gt;&gt;&gt; bart.score
59
</code></pre>
<p><strong>数据封装</strong><br>
在<code>Student</code>类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和<code>Student</code>类本身是关联起来的，我们称之为类的方法：</p>
<pre><code class="language-Python">class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))
</code></pre>
<p>除了<code>self</code>不用传递，其他参数正常传入：</p>
<pre><code class="language-Python">&gt;&gt;&gt; bart.print_score()
Bart Simpson: 59
</code></pre>
<h2 id="访问限制">访问限制</h2>
<p>通过私有变量private实现: <code>__name</code>, <code>__score</code><br>
双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p>
<pre><code class="language-Python">&gt;&gt;&gt; bart._Student__name
'Bart Simpson'
</code></pre>
<h2 id="继承与多态">继承与多态</h2>
<p><strong>多态:</strong> 子类方法与父类重合时会覆盖父类的方法,即优先调用子类的方法.</p>
<pre><code class="language-Python">class Animal(object):
    def run(self):
        print('Animal is running...')
		
class Dog(Animal):
    pass
class Cat(Animal):
    pass
#调用
dog = Dog()
dog.run()
cat = Cat()
cat.run()
#结果
Animal is running...
Animal is running...
#子类方法:
class Dog(Animal):

    def run(self):
        print('Dog is running...')

class Cat(Animal):

    def run(self):
        print('Cat is running...')
#再次调用结果:
Dog is running...
Cat is running...

def run_twice(animal):
    animal.run()
    animal.run()
&gt;&gt;&gt; run_twice(Animal())
Animal is running...
Animal is running...
&gt;&gt;&gt; run_twice(Dog())
Dog is running...
Dog is running...
</code></pre>
<p>Python的动态特点, 不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。<br>
不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了.</p>
<h2 id="获取对象信息">获取对象信息</h2>
<p>type()<br>
isinstance()<br>
<code>dir()</code>:<br>
获得一个str对象的所有属性和方法：</p>
<pre><code class="language-python">&gt;&gt;&gt; dir('ABC')
['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']
</code></pre>
<p><code>getattr()</code>、<code>setattr()</code>、<code>hasattr()</code>，可以直接操作一个对象的状态：</p>
<pre><code class="language-python">&gt;&gt;&gt; class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...
&gt;&gt;&gt; obj = MyObject()
#操作
&gt;&gt;&gt; hasattr(obj, 'x') # 有属性'x'吗？
True
&gt;&gt;&gt; obj.x
9
&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？
False
&gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y'
&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？
True
&gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y'
19
&gt;&gt;&gt; obj.y # 获取属性'y'
19
#传入一个default参数
&gt;&gt;&gt; getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
404
#获得对象的方法：
&gt;&gt;&gt; hasattr(obj, 'power') # 有属性'power'吗？
True
&gt;&gt;&gt; getattr(obj, 'power') # 获取属性'power'
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
&gt;&gt;&gt; fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn
&gt;&gt;&gt; fn # fn指向obj.power
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的
81
</code></pre>
<h2 id="实例属性与类属性">实例属性与类属性</h2>
<p>创建类的属性:</p>
<pre><code class="language-python">class Student(object):
    name = 'Student'
</code></pre>
<p>测试:</p>
<pre><code class="language-python">&gt;&gt;&gt; class Student(object):
...     name = 'Student'
...
&gt;&gt;&gt; s = Student() # 创建实例s
&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
&gt;&gt;&gt; print(Student.name) # 打印类的name属性
Student
&gt;&gt;&gt; s.name = 'Michael' # 给实例绑定name属性
&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
&gt;&gt;&gt; del s.name # 如果删除实例的name属性
&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student
</code></pre>
<p>为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加：</p>
<pre><code class="language-python">class Student(object):
    
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1
        self.count = Student.count
#测试
# 测试:
if Student.count != 0:
    print('测试失败!')
else:
    bart = Student('Bart')
    if Student.count != 1:
        print('测试失败!')
    else:
        lisa = Student('Bart')
        if Student.count != 2:
            print('测试失败!')
        else:
            print('Students:', Student.count)
            print('测试通过!')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0207-高级特性-高级函数]]></title>
        <id>https://foreup.github.io/post/0207-gao-ji-te-xing-gao-ji-han-shu/</id>
        <link href="https://foreup.github.io/post/0207-gao-ji-te-xing-gao-ji-han-shu/">
        </link>
        <updated>2022-02-07T11:21:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="函数的参数">函数的参数</h2>
<p><strong>位置参数</strong><br>
按照对应的位置引用参数；<br>
<strong>默认参数</strong></p>
<pre><code class="language-python">def power(x, n=2):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s
#调用
&gt;&gt;&gt; power(5)
25
&gt;&gt;&gt; power(5, 2)
25
</code></pre>
<p>例子2:</p>
<pre><code class="language-python">def enroll(name, gender, age=6, city='Beijing'):
    print('name:', name)
    print('gender:', gender)
    print('age:', age)
    print('city:', city)
</code></pre>
<p>不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll('Adam', 'M', city='Tianjin')</code>，意思是，city参数用传进去的值，其他默认参数继续使用默认值。<br>
默认参数的<strong>坑</strong>:<br>
定义一个函数，传入一个<code>list</code>，添加一个END再返回：</p>
<pre><code class="language-python">def add_end(L=[]):
    L.append('END')
    return L
#调用
&gt;&gt;&gt; add_end()
['END']
#但是，再次调用add_end()时，结果就不对了：
&gt;&gt;&gt; add_end()
['END', 'END']
&gt;&gt;&gt; add_end()
['END', 'END', 'END']
</code></pre>
<p>应该用None这个不变对象来实现：</p>
<pre><code class="language-python">def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
</code></pre>
<p><strong>可变参数</strong><br>
给定一组数字a，b，c……，请计算a<sup>2</sup> + b<sup>2</sup>  + c<sup>2</sup>  + ……<br>
方法一: 对于提前组装好的<strong>list或tuple</strong>:</p>
<pre><code class="language-python">def calc(numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
#调用
&gt;&gt;&gt; calc([1, 2, 3])
14
&gt;&gt;&gt; calc((1, 3, 5, 7))
84
</code></pre>
<p>方法二:利用可变参数:</p>
<pre><code class="language-python">def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
#直接数字
&gt;&gt;&gt; calc(1, 2)
5
&gt;&gt;&gt; calc()
0
#引用list或tuple:
&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(*nums)
14
</code></pre>
<p><strong>关键字参数</strong><br>
关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<code>dict</code>。</p>
<pre><code class="language-python">def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
#调用
&gt;&gt;&gt; person('Michael', 30)
name: Michael age: 30 other: {}
&gt;&gt;&gt; person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
#调用dict
&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p><strong>命名关键字参数</strong><br>
只接收<code>city</code>和<code>job</code>作为关键字参数, 这种方式定义的函数如下：<br>
用到特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数;</p>
<pre><code class="language-python">def person(name, age, *, city, job):
    print(name, age, city, job)
#调用
&gt;&gt;&gt; person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
#已经有了一个可变参数
def person(name, age, *args, city, job):
    print(name, age, args, city, job)
</code></pre>
<p><strong>参数组合</strong><br>
参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<h2 id="递归函数">递归函数</h2>
<p>计算阶乘<code>n! = 1 x 2 x 3 x ... x n</code></p>
<pre><code class="language-python">def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
</code></pre>
<p>递归调用栈溢出的方法是通过<strong>尾递归</strong>优化:</p>
<pre><code class="language-python">def fact(n):
    return fact_iter(n, 1)
def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
#调用:
fact_iter(5, 1)
===&gt; fact_iter(5, 1)
===&gt; fact_iter(4, 5)
===&gt; fact_iter(3, 20)
===&gt; fact_iter(2, 60)
===&gt; fact_iter(1, 120)
===&gt; 120
</code></pre>
<p>汉诺塔的移动可以用递归函数非常简单地实现。</p>
<pre><code class="language-python"># -*- coding: utf-8 -*-
def move(n, a, b, c):
    if n == 1:
        print(a, '--&gt;', c)
    else:
        move(n - 1, a, c, b)
        print(a, '--&gt;', c)
        move(n - 1, b, a, c)
#调用
move(3, 'A', 'B', 'C')
</code></pre>
<h1 id="高级特性">高级特性</h1>
<h2 id="切片">切片</h2>
<pre><code class="language-python">&gt;&gt;&gt; L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
&gt;&gt;&gt; L[0:3]
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p><code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引<code>3</code>为止，但不包括索引<code>3</code>.<br>
第一个索引是<code>0</code>，可以省略：</p>
<pre><code class="language-python">&gt;&gt;&gt; L[:3]
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p>倒数切片:</p>
<pre><code class="language-python">&gt;&gt;&gt; L[-2:]
['Bob', 'Jack']
&gt;&gt;&gt; L[-2:-1]
['Bob']
&gt;&gt;&gt; L[:10:2]
[0, 2, 4, 6, 8]
</code></pre>
<h2 id="迭代">迭代</h2>
<p><code>dict</code>迭代的是<code>key</code>。如果要迭代<code>value</code>，可以用<code>for value in d.values()</code>，如果要同时迭代<code>key</code>和<code>value</code>，可以用<code>for k, v in d.items()</code>.<br>
判断是否可以迭代:</p>
<pre><code class="language-python">&gt;&gt;&gt; from collections.abc import Iterable
&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代
True
&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代
True
&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代
False
</code></pre>
<h2 id="列表生成式">列表生成式</h2>
<p>把要生成的元素<code>x * x</code>放到前面，后面跟<code>for</code>循环，就可以把<code>list</code>创建出来;</p>
<pre><code class="language-python">&gt;&gt;&gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>
<p>后面还可以接过滤条件：</p>
<pre><code class="language-python">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
</code></pre>
<p>两层循环:</p>
<pre><code class="language-python">&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
</code></pre>
<p><strong>列出</strong>当前目录下的所有<strong>文件和目录名</strong>:</p>
<pre><code class="language-python">&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到
&gt;&gt;&gt; [d for d in os.listdir('.')] # os.listdir可以列出文件和目录
['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode']
</code></pre>
<p>使用两个变量来生成list：</p>
<pre><code class="language-python">&gt;&gt;&gt; d = {'x': 'A', 'y': 'B', 'z': 'C' }
&gt;&gt;&gt; [k + '=' + v for k, v in d.items()]
['y=B', 'x=A', 'z=C']
</code></pre>
<p><strong>if...else...</strong><br>
<code>for</code>后面的<code>if</code>是一个筛选条件，不能带<code>else</code></p>
<pre><code class="language-python">&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0 else 0]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x for x in range(1, 11) if x % 2 == 0 else 0]
                                              ^
SyntaxError: invalid syntax
</code></pre>
<p><code>for</code>前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果,必须加上else：</p>
<pre><code class="language-python">&gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
</code></pre>
<h2 id="生成器">生成器</h2>
<p><strong>1.</strong> 将列表生成式的<code>[]</code>变为<code>()</code>即是生成器:</p>
<pre><code class="language-python">&gt;&gt;&gt; L = [x * x for x in range(10)]
&gt;&gt;&gt; L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;
</code></pre>
<p>可以<code>next()</code>不断生成下一个对象,一般用<code>for...in...</code>迭代产生:</p>
<pre><code class="language-python">&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; next(g)
1
&gt;&gt;&gt; next(g)
4
&gt;&gt;&gt; next(g)
9
&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; for n in g:
...     print(n)
... 
0
1
4
9
.
.
81
</code></pre>
<p><strong>2.</strong> 函数中加<code>yield</code>即为<code>generator</code>函数:<br>
斐波拉契数列生成器:</p>
<pre><code class="language-python">def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
&gt;&gt;&gt; f = fib(6)
&gt;&gt;&gt; f
&lt;generator object fib at 0x104feaaa0&gt;
</code></pre>
<p>调用generator函数会创建一个generator对象，多次调用generator函数会创建多个相互独立的generator。<br>
杨辉三角:</p>
<pre><code class="language-python">def triangles():
    last = [1]
    while True:
        yield last
        next = [last[n]+last[n-1] for n in range(1,len(last))] #中间元素
        next = [1]+next+[1] #首尾加1
        last = next
</code></pre>
<h2 id="迭代器">迭代器</h2>
<p>可以直接作用于<code>for</code>循环的数据类型有以下几种：</p>
<p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p>
<p>一类是<code>generator</code>，包括<code>生成器</code>和带<code>yield</code>的<code>generator function</code>。</p>
<p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。<br>
使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p>
<pre><code class="language-python">&gt;&gt;&gt; from collections.abc import Iterable
&gt;&gt;&gt; isinstance([], Iterable)
True
&gt;&gt;&gt; isinstance({}, Iterable)
True
&gt;&gt;&gt; isinstance('abc', Iterable)
True
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)
True
&gt;&gt;&gt; isinstance(100, Iterable)
False
</code></pre>
<p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。</p>
<p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</p>
<pre><code class="language-python">&gt;&gt;&gt; from collections.abc import Iterator
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)
True
&gt;&gt;&gt; isinstance([], Iterator)
False
&gt;&gt;&gt; isinstance({}, Iterator)
False
&gt;&gt;&gt; isinstance('abc', Iterator)
False
</code></pre>
<p>不能提前知道序列的长度，只能通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。<br>
<code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。</p>
<h1 id="函数式编程">函数式编程</h1>
<h2 id="高阶函数">高阶函数</h2>
<p>把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。<br>
简单的示例:</p>
<pre><code class="language-python">def add(x, y, f):
    return f(x) + f(y)
</code></pre>
<p><strong>map/reduce</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; def f(x):
...     return x * x
...
&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
#reduce
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<p>利用map和reduce编写一个str2float函数:</p>
<pre><code class="language-python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from functools import reduce

def str2float(s):
    DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
    index = s.find('.')
    def char2num(s):
        return DIGITS[s]
    to_int = reduce(lambda x, y: x * 10 + y, map(char2num, s.replace('.','')))
    return to_int * (10 ** (index - len(s) + 1))                # s含小数点，所以index-len(s)会多减去一位数，需要加1补足

print(str2float('111.11'))
</code></pre>
<p><strong>filter</strong><br>
<code>str.strip( '0' );</code>  # 去除首尾字符 0<br>
<code>str2.strip();</code>  #去除首尾空格<br>
<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True:</code>保留;还是<code>False:</code>丢弃该元素。<br>
保留奇数:</p>
<pre><code class="language-python">def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]
</code></pre>
<p>求素数:利用埃氏筛法</p>
<pre><code class="language-python">构造一个从3开始的奇数序列：
def _odd_iter():
    n = 1
    while True:
        n = n + 2
        yield n
定义一个筛选函数：
def _not_divisible(n):
    return lambda x: x % n &gt; 0
定义一个生成器，不断返回下一个素数：
def primes():
    yield 2
    it = _odd_iter() # 初始序列
    while True:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列
设置一个退出循环的条件：
# 打印1000以内的素数:
for n in primes():
    if n &lt; 1000:
        print(n)
    else:
        break
</code></pre>
<p>利用<strong>filter()</strong> 筛选出<strong>回数</strong>：</p>
<pre><code class="language-python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def is_palindrome(n):
    a=str(n)
    b=a[::-1]
    if a==b:
        return n
# 测试:
output = filter(is_palindrome, range(1, 1000))
print('1~1000:', list(output))
</code></pre>
<p><strong>sorted</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
</code></pre>
<p><code>key</code>选择的函数是对<code>list</code>的<strong>每项</strong>作用, 而不是作用在整个<code>list</code><br>
要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p>
<pre><code class="language-python">&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0206-underscore-Python]]></title>
        <id>https://foreup.github.io/post/0206-underscore-python/</id>
        <link href="https://foreup.github.io/post/0206-underscore-python/">
        </link>
        <updated>2022-02-06T12:13:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="function">Function</h2>
<h3 id="bind">bind</h3>
<p>错误函数用法示例:</p>
<pre><code class="language-JavaScript">'use strict';
var s = ' Hello  ';
s.trim();
// 输出'Hello'
var fn = s.trim;
fn();
// Uncaught TypeError: String.prototype.trim called on null or undefined
</code></pre>
<p>用<code>fn()</code>取代<code>s.trim()</code>, 上述方法的<code>fn()</code>传入的<code>this</code>指针是<code>undefined</code>, 应该这么用:</p>
<pre><code class="language-JavaScript">var s = ' Hello  ';
var fn = s.trim;
// 调用call并传入s对象作为this:
fn.call(s)
// 输出Hello
</code></pre>
<p><code>bind()</code>可以将<code>s</code>绑定到<code>fn()</code>的<code>this</code>上, 修复之前的错误:</p>
<pre><code class="language-JavaScript">var s = ' Hello  ';
var fn = _.bind(s.trim, s);
fn();
</code></pre>
<h3 id="partial">partial</h3>
<p><code>partial()</code>创建偏函数;<br>
创建<code>pow2N(n)</code>实现<code>Math.pow(2,n)</code>;</p>
<pre><code class="language-JavaScript">'use strict';
var pow2N = _.partial(Math.pow, 2);
pow2N(3); // 8
pow2N(5); // 32
pow2N(10); // 1024
</code></pre>
<p>创建<code>cube(x)</code>，计算<code>x^3</code>，可以用<code>_</code>作占位符，固定住第二个参数：</p>
<pre><code class="language-JavaScript">var cube = _.partial(Math.pow, _, 3);
cube(3); // 27
cube(5); // 125
cube(10); // 1000
</code></pre>
<h3 id="memoize">memoize</h3>
<p>用<code>memoize()</code>自动缓存函数计算的结果：</p>
<pre><code class="language-JavaScript">var factorial = _.memoize(function(n) {
    console.log('start calculate ' + n + '!...');
    var s = 1, i = n;
    while (i &gt; 1) {
        s = s * i;
        i --;
    }
    console.log(n + '! = ' + s);
    return s;
});
// 第一次调用:
factorial(10); // 3628800
// 注意控制台输出:
// start calculate 10!...
// 10! = 3628800
// 第二次调用:
factorial(10); // 3628800
// 控制台没有输出
</code></pre>
<p>但是<code>factorial(9);</code>仍然会重新计算, 可以利用<strong>递归调用</strong>实现阶乘的逐步缓存:</p>
<pre><code class="language-JavaScript">var factorial = _.memoize(function(n) {
    console.log('start calculate ' + n + '!...');
    if (n &lt; 2) {
        return 1;
    }
    return n * factorial(n - 1);
});
factorial(10); // 3628800
// 输出结果说明factorial(1)~factorial(10)都已经缓存了:
// start calculate 10!...
// start calculate 9!...
// start calculate 8!...
// start calculate 7!...
// start calculate 6!...
// start calculate 5!...
// start calculate 4!...
// start calculate 3!...
// start calculate 2!...
// start calculate 1!...
factorial(9); // 362880
// console无输出
</code></pre>
<h3 id="once">once</h3>
<p>once()保证某个函数执行且仅执行一次:</p>
<pre><code class="language-JavaScript">var register = _.once(function () {
    alert('Register ok!');
});
// 测试效果:
register();
register(); //之后无弹窗
register();
</code></pre>
<h3 id="delay">delay</h3>
<pre><code class="language-JavaScript">'use strict';
// 2秒后调用alert():
_.delay(alert, 2000);
</code></pre>
<p>延迟调用的函数有参数:</p>
<pre><code class="language-JavaScript">var log = _.bind(console.log, console);
_.delay(log, 2000, 'Hello,', 'world!');
// 2秒后打印'Hello, world!':
</code></pre>
<h1 id="python">Python</h1>
<h2 id="字符串编码">字符串编码</h2>
<p><code>ord()</code>获取字符的整数表示，<code>chr()</code>把编码转换为对应的字符：</p>
<pre><code class="language-Python">&gt;&gt;&gt; ord('A')
65
&gt;&gt;&gt; ord('中')
20013
&gt;&gt;&gt; chr(66)
'B'
&gt;&gt;&gt; chr(25991)
'文'
</code></pre>
<p>用十六进制这么写<code>str</code>：</p>
<pre><code class="language-Python">&gt;&gt;&gt; '\u4e2d\u6587'  #4e2d&gt;20013&gt;'中'
'中文'
</code></pre>
<p>字符串类型为<code>str</code>，在网络上传输或保存到磁盘需要转化为字节为单位的<code>bytes</code>数据，用带<code>b</code>前缀的单引号或双引号表示：<code>'ABC'</code>和<code>b'ABC'</code>不同。<br>
<strong>encode()与decode()</strong><br>
<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>：</p>
<pre><code class="language-Python">&gt;&gt;&gt; 'ABC'.encode('ascii')
b'ABC'
&gt;&gt;&gt; '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
&gt;&gt;&gt; '中文'.encode('ascii')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
</code></pre>
<p>把<code>bytes</code>变为<code>str</code>，需要用<code>decode()</code>:</p>
<pre><code class="language-Python">&gt;&gt;&gt; b'ABC'.decode('ascii')
'ABC'
&gt;&gt;&gt; b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'
</code></pre>
<p>如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors='ignore'</code>忽略错误的字节：</p>
<pre><code class="language-Python">&gt;&gt;&gt; b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore')
'中'
</code></pre>
<p><strong>len()</strong><br>
计算<code>str</code>的字符数用<code>len()</code>:</p>
<pre><code class="language-Python">&gt;&gt;&gt; len('ABC')
3
&gt;&gt;&gt; len('中文')
2
</code></pre>
<p>如果换成<code>bytes</code>就计算字节数:</p>
<pre><code class="language-Python">&gt;&gt;&gt; len(b'ABC')
3
&gt;&gt;&gt; len(b'\xe4\xb8\xad\xe6\x96\x87')
6
&gt;&gt;&gt; len('中文'.encode('utf-8'))
6
</code></pre>
<p><strong>占位符</strong><br>
<code>x%</code> ——十六进制整数;<br>
<code>%s</code>永远起作用，它会把任何数据类型转换为字符串：</p>
<pre><code class="language-Python">&gt;&gt;&gt; 'Age: %s. Gender: %s' % (25, True)
'Age: 25. Gender: True'
#format(), 占位符{0}、{1}…
&gt;&gt;&gt; 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)
'Hello, 小明, 成绩提升了 17.1%'
</code></pre>
<p>f-string, 若包含{xxx}，就会以对应的变量替换：</p>
<pre><code class="language-Python">&gt;&gt;&gt; r = 2.5
&gt;&gt;&gt; s = 3.14 * r ** 2
&gt;&gt;&gt; print(f'The area of a circle with radius {r} is {s:.2f}')
The area of a circle with radius 2.5 is 19.62
</code></pre>
<p>除了特殊需求，牢记仅使用<strong>UTF-8</strong>编码。</p>
<h2 id="list与tuple">list与tuple</h2>
<p><strong>list</strong></p>
<pre><code class="language-Python">&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']
&gt;&gt;&gt; classmates
['Michael', 'Bob', 'Tracy']
</code></pre>
<p>len()函数可以获得list元素的个数:<code>len(classmates) //3</code></p>
<pre><code class="language-Python">&gt;&gt;&gt; classmates[0]
'Michael'
&gt;&gt;&gt; classmates[1]
'Bob'
&gt;&gt;&gt; classmates[2]
'Tracy'
&gt;&gt;&gt; classmates[3]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
IndexError: list index out of range
</code></pre>
<p>访问倒数第n个元素:</p>
<pre><code class="language-Python">&gt;&gt;&gt; classmates[-1]
'Tracy'
&gt;&gt;&gt; classmates[-2]
'Bob'
&gt;&gt;&gt; classmates[-3]
'Michael'
&gt;&gt;&gt; classmates[-4]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
IndexError: list index out of range
</code></pre>
<p><strong>追加元素</strong></p>
<pre><code class="language-Python">#从末尾追加
&gt;&gt;&gt; classmates.append('Adam')
&gt;&gt;&gt; classmates
['Michael', 'Bob', 'Tracy', 'Adam']
#按索引插入
&gt;&gt;&gt; classmates.insert(1, 'Jack')
&gt;&gt;&gt; classmates
['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']
#删除末尾
&gt;&gt;&gt; classmates.pop()
'Adam'
&gt;&gt;&gt; classmates
['Michael', 'Jack', 'Bob', 'Tracy']
#索引弹出
&gt;&gt;&gt; classmates.pop(1)
'Jack'
&gt;&gt;&gt; classmates
['Michael', 'Bob', 'Tracy']
#替换
&gt;&gt;&gt; classmates[1] = 'Sarah'
&gt;&gt;&gt; classmates
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p><strong>list套list——多维数组</strong></p>
<pre><code class="language-Python">&gt;&gt;&gt; s = ['python', 'java', ['asp', 'php'], 'scheme']
&gt;&gt;&gt; len(s)
4
</code></pre>
<p><strong>tuple</strong><br>
理解“指向不变”:</p>
<pre><code class="language-Python">&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])
&gt;&gt;&gt; t[2][0] = 'X'
&gt;&gt;&gt; t[2][1] = 'Y'
&gt;&gt;&gt; t
('a', 'b', ['X', 'Y'])
</code></pre>
<h2 id="条件判断">条件判断</h2>
<pre><code class="language-Python">if &lt;条件判断1&gt;:
    &lt;执行1&gt;
elif &lt;条件判断2&gt;:
    &lt;执行2&gt;
elif &lt;条件判断3&gt;:
    &lt;执行3&gt;
else:
    &lt;执行4&gt;
</code></pre>
<h2 id="循环">循环</h2>
<p><code>for...in...</code><br>
<code>for x in ...</code>循环就是把每个元素代入变量x，然后执行缩进块的语句。</p>
<pre><code class="language-Python">names = ['Michael', 'Bob', 'Tracy']
for name in names:
    print(name)
</code></pre>
<p><code>range(101)</code>生成0-100的整数序列.<br>
<code>while</code>循环</p>
<pre><code class="language-Python">sum = 0
n = 99
while n &gt; 0:
    sum = sum + n
    n = n - 2
print(sum)
</code></pre>
<h2 id="dict与set">dict与set</h2>
<p>dict在其他语言中Map对象。<br>
<strong>总述：</strong> 列表 <code>list[]</code> 、元组 <code>tuple()</code> 、字典 <code>dict{ key : value }</code> 、无序不重复元素集合  <code>set(list[])</code>  ，后两者的key为不可变对象, 元组元素&quot;指向&quot;不可变。<br>
对于 <strong>不变对象</strong> 来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。<br>
重复元素在set中自动被过滤：</p>
<pre><code class="language-python">&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])
&gt;&gt;&gt; s
{1, 2, 3}
</code></pre>
<p>添加元素到<code>set</code>中:</p>
<pre><code class="language-python">&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}
&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}
</code></pre>
<p>删除元素：</p>
<pre><code class="language-python">&gt;&gt;&gt; s.remove(4)
&gt;&gt;&gt; s
{1, 2, 3}
</code></pre>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>
<pre><code class="language-python">&gt;&gt;&gt; s1 = set([1, 2, 3])
&gt;&gt;&gt; s2 = set([2, 3, 4])
&gt;&gt;&gt; s1 &amp; s2
{2, 3}
&gt;&gt;&gt; s1 | s2
{1, 2, 3, 4}
</code></pre>
<h2 id="调用函数">调用函数</h2>
<p><code>max()</code>函数可以接受任意多个参数, 并返回最大的数:</p>
<pre><code class="language-python">&gt;&gt;&gt; max(1, 2)
2
&gt;&gt;&gt; max(2, 3, 1, -5)
3
</code></pre>
<h2 id="定义函数">定义函数</h2>
<p><strong>空函数</strong></p>
<pre><code class="language-python">def nop():
    pass
</code></pre>
<p><code>pass</code>可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来, 也可以放到其他语句中:</p>
<pre><code class="language-python">if age &gt;= 18:
    pass
</code></pre>
<p><strong>参数检查</strong><br>
数据类型检查可以用内置函数<code>isinstance()</code>实现：</p>
<pre><code class="language-python">def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x &gt;= 0:
        return x
    else:
        return -x
</code></pre>
<p><strong>返回多个值</strong><br>
游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：</p>
<pre><code class="language-python">import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
</code></pre>
<p>Python函数返回的仍然是单一值：</p>
<pre><code class="language-python">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)
&gt;&gt;&gt; print(r)
(151.96152422706632, 70.0)
</code></pre>
<h2 id="函数的参数">函数的参数</h2>
<p>明天</p>
]]></content>
    </entry>
</feed>