{"posts":[{"title":"0208-函数-对象编程","content":"返回函数 类似js的闭包; 例子1: def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs 计数器: 在fn()函数内部加一个nonlocal x的声明, 解释器把fn()的x看作外层函数的局部变量，它已经被初始化了，可以正确计算x+1. def createCounter(): x = 0 def counter(): nonlocal x #去掉会报错 x = x +1 return x return counter f = createCounter() print(f()) # 1 print(f()) # 2 print(f()) # 3 print(f()) # 4 匿名函数 lambda 定义了匿名函数 过滤偶数: filter 中的函数参数没有()与参数 # -*- coding: utf-8 -*- def is_odd(n): return n % 2 == 1 L = list(filter(is_odd, range(1, 20))) #is_odd不需要写参数 #通过匿名函数 L = list(filter(lambda x : x % 2 == 1, range(1, 20))) 装饰器 wrapper() 函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。 wrapper.__name__ = func.__name__等同于Python内置的@functools.wraps(func) 设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间： # -*- coding: utf-8 -*- import time, functools def metric(fn): @functools.wraps(fn) def wrapper(*args,**kw): startTime = time.time() result = fn(*args,**kw) endTime = time.time() excuteTime = 1000 * (endTime- startTime) print('%s executed in %s ms' % (fn.__name__, excuteTime)) return result return wrapper # 测试 @metric def fast(x, y): time.sleep(0.0012) return x + y; @metric def slow(x, y, z): time.sleep(0.1234) return x * y * z; f = fast(11, 22) s = slow(11, 22, 33) ##输出 fast executed in 1.293182373046875 ms slow executed in 123.56829643249512 ms 带参数的decorator import functools def log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator #定义函数 @log('execute') def now(): print('2015-3-25') #执行结果 &gt;&gt;&gt; now() execute now(): 2015-3-25 偏函数 int() 函数提供 base 参数，默认值为 10。如果传入 base 参数，就可以做N进制的转换： &gt;&gt;&gt; int('12345', base=8) 5349 &gt;&gt;&gt; int('12345', 16) 74565 利用偏函数固定参数: functools.partial 固定函数的某个参数, 实现简化函数调用 &gt;&gt;&gt; import functools &gt;&gt;&gt; int2 = functools.partial(int, base=2) &gt;&gt;&gt; int2('1000000') 64 &gt;&gt;&gt; int2('1010101') 85 模块 以内建的 sys 模块为例: #!/usr/bin/env python3 # -*- coding: utf-8 -*- ' a test module ' __author__ = 'Michael Liao' import sys def test(): args = sys.argv if len(args)==1: print('Hello, world!') elif len(args)==2: print('Hello, %s!' % args[1]) else: print('Too many arguments!') if __name__=='__main__': test() 作用域 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等； Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。 private函数的作用示例: def _private_1(name): return 'Hello, %s' % name def _private_2(name): return 'Hi, %s' % name def greeting(name): if len(name) &gt; 3: return _private_1(name) else: return _private_2(name) 面向对象编程 类和实例 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。 定义类: class Student(object): def __init__(self, name, score): self.name = name self.score = score (object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 &gt;&gt;&gt; bart = Student('Bart Simpson', 59) &gt;&gt;&gt; bart.name 'Bart Simpson' &gt;&gt;&gt; bart.score 59 数据封装 在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法： class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 除了self不用传递，其他参数正常传入： &gt;&gt;&gt; bart.print_score() Bart Simpson: 59 访问限制 通过私有变量private实现: __name, __score 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量： &gt;&gt;&gt; bart._Student__name 'Bart Simpson' 继承与多态 多态: 子类方法与父类重合时会覆盖父类的方法,即优先调用子类的方法. class Animal(object): def run(self): print('Animal is running...') class Dog(Animal): pass class Cat(Animal): pass #调用 dog = Dog() dog.run() cat = Cat() cat.run() #结果 Animal is running... Animal is running... #子类方法: class Dog(Animal): def run(self): print('Dog is running...') class Cat(Animal): def run(self): print('Cat is running...') #再次调用结果: Dog is running... Cat is running... def run_twice(animal): animal.run() animal.run() &gt;&gt;&gt; run_twice(Animal()) Animal is running... Animal is running... &gt;&gt;&gt; run_twice(Dog()) Dog is running... Dog is running... Python的动态特点, 不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了. 获取对象信息 type() isinstance() dir(): 获得一个str对象的所有属性和方法： &gt;&gt;&gt; dir('ABC') ['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill'] getattr()、setattr()、hasattr()，可以直接操作一个对象的状态： &gt;&gt;&gt; class MyObject(object): ... def __init__(self): ... self.x = 9 ... def power(self): ... return self.x * self.x ... &gt;&gt;&gt; obj = MyObject() #操作 &gt;&gt;&gt; hasattr(obj, 'x') # 有属性'x'吗？ True &gt;&gt;&gt; obj.x 9 &gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？ False &gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y' &gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？ True &gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y' 19 &gt;&gt;&gt; obj.y # 获取属性'y' 19 #传入一个default参数 &gt;&gt;&gt; getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404 404 #获得对象的方法： &gt;&gt;&gt; hasattr(obj, 'power') # 有属性'power'吗？ True &gt;&gt;&gt; getattr(obj, 'power') # 获取属性'power' &lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt; &gt;&gt;&gt; fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn &gt;&gt;&gt; fn # fn指向obj.power &lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt; &gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的 81 实例属性与类属性 创建类的属性: class Student(object): name = 'Student' 测试: &gt;&gt;&gt; class Student(object): ... name = 'Student' ... &gt;&gt;&gt; s = Student() # 创建实例s &gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性 Student &gt;&gt;&gt; print(Student.name) # 打印类的name属性 Student &gt;&gt;&gt; s.name = 'Michael' # 给实例绑定name属性 &gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性 Michael &gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问 Student &gt;&gt;&gt; del s.name # 如果删除实例的name属性 &gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了 Student 为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加： class Student(object): count = 0 def __init__(self, name): self.name = name Student.count += 1 self.count = Student.count #测试 # 测试: if Student.count != 0: print('测试失败!') else: bart = Student('Bart') if Student.count != 1: print('测试失败!') else: lisa = Student('Bart') if Student.count != 2: print('测试失败!') else: print('Students:', Student.count) print('测试通过!') ","link":"https://foreup.github.io/post/0208-han-shu-dui-xiang-bian-cheng/"},{"title":"0207-高级特性-高级函数","content":"函数的参数 位置参数 按照对应的位置引用参数； 默认参数 def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s #调用 &gt;&gt;&gt; power(5) 25 &gt;&gt;&gt; power(5, 2) 25 例子2: def enroll(name, gender, age=6, city='Beijing'): print('name:', name) print('gender:', gender) print('age:', age) print('city:', city) 不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin')，意思是，city参数用传进去的值，其他默认参数继续使用默认值。 默认参数的坑: 定义一个函数，传入一个list，添加一个END再返回： def add_end(L=[]): L.append('END') return L #调用 &gt;&gt;&gt; add_end() ['END'] #但是，再次调用add_end()时，结果就不对了： &gt;&gt;&gt; add_end() ['END', 'END'] &gt;&gt;&gt; add_end() ['END', 'END', 'END'] 应该用None这个不变对象来实现： def add_end(L=None): if L is None: L = [] L.append('END') return L 可变参数 给定一组数字a，b，c……，请计算a2 + b2 + c2 + …… 方法一: 对于提前组装好的list或tuple: def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum #调用 &gt;&gt;&gt; calc([1, 2, 3]) 14 &gt;&gt;&gt; calc((1, 3, 5, 7)) 84 方法二:利用可变参数: def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum #直接数字 &gt;&gt;&gt; calc(1, 2) 5 &gt;&gt;&gt; calc() 0 #引用list或tuple: &gt;&gt;&gt; nums = [1, 2, 3] &gt;&gt;&gt; calc(*nums) 14 关键字参数 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。 def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) #调用 &gt;&gt;&gt; person('Michael', 30) name: Michael age: 30 other: {} &gt;&gt;&gt; person('Bob', 35, city='Beijing') name: Bob age: 35 other: {'city': 'Beijing'} &gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer') name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'} #调用dict &gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'} &gt;&gt;&gt; person('Jack', 24, **extra) name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'} 命名关键字参数 只接收city和job作为关键字参数, 这种方式定义的函数如下： 用到特殊分隔符*，*后面的参数被视为命名关键字参数; def person(name, age, *, city, job): print(name, age, city, job) #调用 &gt;&gt;&gt; person('Jack', 24, city='Beijing', job='Engineer') Jack 24 Beijing Engineer #已经有了一个可变参数 def person(name, age, *args, city, job): print(name, age, args, city, job) 参数组合 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 递归函数 计算阶乘n! = 1 x 2 x 3 x ... x n def fact(n): if n==1: return 1 return n * fact(n - 1) 递归调用栈溢出的方法是通过尾递归优化: def fact(n): return fact_iter(n, 1) def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) #调用: fact_iter(5, 1) ===&gt; fact_iter(5, 1) ===&gt; fact_iter(4, 5) ===&gt; fact_iter(3, 20) ===&gt; fact_iter(2, 60) ===&gt; fact_iter(1, 120) ===&gt; 120 汉诺塔的移动可以用递归函数非常简单地实现。 # -*- coding: utf-8 -*- def move(n, a, b, c): if n == 1: print(a, '--&gt;', c) else: move(n - 1, a, c, b) print(a, '--&gt;', c) move(n - 1, b, a, c) #调用 move(3, 'A', 'B', 'C') 高级特性 切片 &gt;&gt;&gt; L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack'] &gt;&gt;&gt; L[0:3] ['Michael', 'Sarah', 'Tracy'] L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3. 第一个索引是0，可以省略： &gt;&gt;&gt; L[:3] ['Michael', 'Sarah', 'Tracy'] 倒数切片: &gt;&gt;&gt; L[-2:] ['Bob', 'Jack'] &gt;&gt;&gt; L[-2:-1] ['Bob'] &gt;&gt;&gt; L[:10:2] [0, 2, 4, 6, 8] 迭代 dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items(). 判断是否可以迭代: &gt;&gt;&gt; from collections.abc import Iterable &gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代 True &gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代 True &gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代 False 列表生成式 把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来; &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 后面还可以接过滤条件： &gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] 两层循环: &gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ'] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 列出当前目录下的所有文件和目录名: &gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到 &gt;&gt;&gt; [d for d in os.listdir('.')] # os.listdir可以列出文件和目录 ['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode'] 使用两个变量来生成list： &gt;&gt;&gt; d = {'x': 'A', 'y': 'B', 'z': 'C' } &gt;&gt;&gt; [k + '=' + v for k, v in d.items()] ['y=B', 'x=A', 'z=C'] if...else... for后面的if是一个筛选条件，不能带else &gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0 else 0] File &quot;&lt;stdin&gt;&quot;, line 1 [x for x in range(1, 11) if x % 2 == 0 else 0] ^ SyntaxError: invalid syntax for前面的部分是一个表达式，它必须根据x计算出一个结果,必须加上else： &gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)] [-1, 2, -3, 4, -5, 6, -7, 8, -9, 10] 生成器 1. 将列表生成式的[]变为()即是生成器: &gt;&gt;&gt; L = [x * x for x in range(10)] &gt;&gt;&gt; L [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] &gt;&gt;&gt; g = (x * x for x in range(10)) &gt;&gt;&gt; g &lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 可以next()不断生成下一个对象,一般用for...in...迭代产生: &gt;&gt;&gt; next(g) 0 &gt;&gt;&gt; next(g) 1 &gt;&gt;&gt; next(g) 4 &gt;&gt;&gt; next(g) 9 &gt;&gt;&gt; g = (x * x for x in range(10)) &gt;&gt;&gt; for n in g: ... print(n) ... 0 1 4 9 . . 81 2. 函数中加yield即为generator函数: 斐波拉契数列生成器: def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done' &gt;&gt;&gt; f = fib(6) &gt;&gt;&gt; f &lt;generator object fib at 0x104feaaa0&gt; 调用generator函数会创建一个generator对象，多次调用generator函数会创建多个相互独立的generator。 杨辉三角: def triangles(): last = [1] while True: yield last next = [last[n]+last[n-1] for n in range(1,len(last))] #中间元素 next = [1]+next+[1] #首尾加1 last = next 迭代器 可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。 使用isinstance()判断一个对象是否是Iterable对象： &gt;&gt;&gt; from collections.abc import Iterable &gt;&gt;&gt; isinstance([], Iterable) True &gt;&gt;&gt; isinstance({}, Iterable) True &gt;&gt;&gt; isinstance('abc', Iterable) True &gt;&gt;&gt; isinstance((x for x in range(10)), Iterable) True &gt;&gt;&gt; isinstance(100, Iterable) False 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 可以使用isinstance()判断一个对象是否是Iterator对象： &gt;&gt;&gt; from collections.abc import Iterator &gt;&gt;&gt; isinstance((x for x in range(10)), Iterator) True &gt;&gt;&gt; isinstance([], Iterator) False &gt;&gt;&gt; isinstance({}, Iterator) False &gt;&gt;&gt; isinstance('abc', Iterator) False 不能提前知道序列的长度，只能通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。 函数式编程 高阶函数 把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。 简单的示例: def add(x, y, f): return f(x) + f(y) map/reduce &gt;&gt;&gt; def f(x): ... return x * x ... &gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) &gt;&gt;&gt; list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] #reduce reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 利用map和reduce编写一个str2float函数: #!/usr/bin/env python3 # -*- coding: utf-8 -*- from functools import reduce def str2float(s): DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9} index = s.find('.') def char2num(s): return DIGITS[s] to_int = reduce(lambda x, y: x * 10 + y, map(char2num, s.replace('.',''))) return to_int * (10 ** (index - len(s) + 1)) # s含小数点，所以index-len(s)会多减去一位数，需要加1补足 print(str2float('111.11')) filter str.strip( '0' ); # 去除首尾字符 0 str2.strip(); #去除首尾空格 filter()把传入的函数依次作用于每个元素，然后根据返回值是True:保留;还是False:丢弃该元素。 保留奇数: def is_odd(n): return n % 2 == 1 list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) # 结果: [1, 5, 9, 15] 求素数:利用埃氏筛法 构造一个从3开始的奇数序列： def _odd_iter(): n = 1 while True: n = n + 2 yield n 定义一个筛选函数： def _not_divisible(n): return lambda x: x % n &gt; 0 定义一个生成器，不断返回下一个素数： def primes(): yield 2 it = _odd_iter() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(_not_divisible(n), it) # 构造新序列 设置一个退出循环的条件： # 打印1000以内的素数: for n in primes(): if n &lt; 1000: print(n) else: break 利用filter() 筛选出回数： #!/usr/bin/env python3 # -*- coding: utf-8 -*- def is_palindrome(n): a=str(n) b=a[::-1] if a==b: return n # 测试: output = filter(is_palindrome, range(1, 1000)) print('1~1000:', list(output)) sorted &gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs) [5, 9, -12, -21, 36] key选择的函数是对list的每项作用, 而不是作用在整个list 要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True： &gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True) ['Zoo', 'Credit', 'bob', 'about'] ","link":"https://foreup.github.io/post/0207-gao-ji-te-xing-gao-ji-han-shu/"},{"title":"0206-underscore-Python","content":"Function bind 错误函数用法示例: 'use strict'; var s = ' Hello '; s.trim(); // 输出'Hello' var fn = s.trim; fn(); // Uncaught TypeError: String.prototype.trim called on null or undefined 用fn()取代s.trim(), 上述方法的fn()传入的this指针是undefined, 应该这么用: var s = ' Hello '; var fn = s.trim; // 调用call并传入s对象作为this: fn.call(s) // 输出Hello bind()可以将s绑定到fn()的this上, 修复之前的错误: var s = ' Hello '; var fn = _.bind(s.trim, s); fn(); partial partial()创建偏函数; 创建pow2N(n)实现Math.pow(2,n); 'use strict'; var pow2N = _.partial(Math.pow, 2); pow2N(3); // 8 pow2N(5); // 32 pow2N(10); // 1024 创建cube(x)，计算x^3，可以用_作占位符，固定住第二个参数： var cube = _.partial(Math.pow, _, 3); cube(3); // 27 cube(5); // 125 cube(10); // 1000 memoize 用memoize()自动缓存函数计算的结果： var factorial = _.memoize(function(n) { console.log('start calculate ' + n + '!...'); var s = 1, i = n; while (i &gt; 1) { s = s * i; i --; } console.log(n + '! = ' + s); return s; }); // 第一次调用: factorial(10); // 3628800 // 注意控制台输出: // start calculate 10!... // 10! = 3628800 // 第二次调用: factorial(10); // 3628800 // 控制台没有输出 但是factorial(9);仍然会重新计算, 可以利用递归调用实现阶乘的逐步缓存: var factorial = _.memoize(function(n) { console.log('start calculate ' + n + '!...'); if (n &lt; 2) { return 1; } return n * factorial(n - 1); }); factorial(10); // 3628800 // 输出结果说明factorial(1)~factorial(10)都已经缓存了: // start calculate 10!... // start calculate 9!... // start calculate 8!... // start calculate 7!... // start calculate 6!... // start calculate 5!... // start calculate 4!... // start calculate 3!... // start calculate 2!... // start calculate 1!... factorial(9); // 362880 // console无输出 once once()保证某个函数执行且仅执行一次: var register = _.once(function () { alert('Register ok!'); }); // 测试效果: register(); register(); //之后无弹窗 register(); delay 'use strict'; // 2秒后调用alert(): _.delay(alert, 2000); 延迟调用的函数有参数: var log = _.bind(console.log, console); _.delay(log, 2000, 'Hello,', 'world!'); // 2秒后打印'Hello, world!': Python 字符串编码 ord()获取字符的整数表示，chr()把编码转换为对应的字符： &gt;&gt;&gt; ord('A') 65 &gt;&gt;&gt; ord('中') 20013 &gt;&gt;&gt; chr(66) 'B' &gt;&gt;&gt; chr(25991) '文' 用十六进制这么写str： &gt;&gt;&gt; '\\u4e2d\\u6587' #4e2d&gt;20013&gt;'中' '中文' 字符串类型为str，在网络上传输或保存到磁盘需要转化为字节为单位的bytes数据，用带b前缀的单引号或双引号表示：'ABC'和b'ABC'不同。 encode()与decode() str通过encode()方法可以编码为指定的bytes： &gt;&gt;&gt; 'ABC'.encode('ascii') b'ABC' &gt;&gt;&gt; '中文'.encode('utf-8') b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' &gt;&gt;&gt; '中文'.encode('ascii') Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 把bytes变为str，需要用decode(): &gt;&gt;&gt; b'ABC'.decode('ascii') 'ABC' &gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8') '中文' 如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节： &gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xff'.decode('utf-8', errors='ignore') '中' len() 计算str的字符数用len(): &gt;&gt;&gt; len('ABC') 3 &gt;&gt;&gt; len('中文') 2 如果换成bytes就计算字节数: &gt;&gt;&gt; len(b'ABC') 3 &gt;&gt;&gt; len(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87') 6 &gt;&gt;&gt; len('中文'.encode('utf-8')) 6 占位符 x% ——十六进制整数; %s永远起作用，它会把任何数据类型转换为字符串： &gt;&gt;&gt; 'Age: %s. Gender: %s' % (25, True) 'Age: 25. Gender: True' #format(), 占位符{0}、{1}… &gt;&gt;&gt; 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125) 'Hello, 小明, 成绩提升了 17.1%' f-string, 若包含{xxx}，就会以对应的变量替换： &gt;&gt;&gt; r = 2.5 &gt;&gt;&gt; s = 3.14 * r ** 2 &gt;&gt;&gt; print(f'The area of a circle with radius {r} is {s:.2f}') The area of a circle with radius 2.5 is 19.62 除了特殊需求，牢记仅使用UTF-8编码。 list与tuple list &gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy'] &gt;&gt;&gt; classmates ['Michael', 'Bob', 'Tracy'] len()函数可以获得list元素的个数:len(classmates) //3 &gt;&gt;&gt; classmates[0] 'Michael' &gt;&gt;&gt; classmates[1] 'Bob' &gt;&gt;&gt; classmates[2] 'Tracy' &gt;&gt;&gt; classmates[3] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: list index out of range 访问倒数第n个元素: &gt;&gt;&gt; classmates[-1] 'Tracy' &gt;&gt;&gt; classmates[-2] 'Bob' &gt;&gt;&gt; classmates[-3] 'Michael' &gt;&gt;&gt; classmates[-4] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: list index out of range 追加元素 #从末尾追加 &gt;&gt;&gt; classmates.append('Adam') &gt;&gt;&gt; classmates ['Michael', 'Bob', 'Tracy', 'Adam'] #按索引插入 &gt;&gt;&gt; classmates.insert(1, 'Jack') &gt;&gt;&gt; classmates ['Michael', 'Jack', 'Bob', 'Tracy', 'Adam'] #删除末尾 &gt;&gt;&gt; classmates.pop() 'Adam' &gt;&gt;&gt; classmates ['Michael', 'Jack', 'Bob', 'Tracy'] #索引弹出 &gt;&gt;&gt; classmates.pop(1) 'Jack' &gt;&gt;&gt; classmates ['Michael', 'Bob', 'Tracy'] #替换 &gt;&gt;&gt; classmates[1] = 'Sarah' &gt;&gt;&gt; classmates ['Michael', 'Sarah', 'Tracy'] list套list——多维数组 &gt;&gt;&gt; s = ['python', 'java', ['asp', 'php'], 'scheme'] &gt;&gt;&gt; len(s) 4 tuple 理解“指向不变”: &gt;&gt;&gt; t = ('a', 'b', ['A', 'B']) &gt;&gt;&gt; t[2][0] = 'X' &gt;&gt;&gt; t[2][1] = 'Y' &gt;&gt;&gt; t ('a', 'b', ['X', 'Y']) 条件判断 if &lt;条件判断1&gt;: &lt;执行1&gt; elif &lt;条件判断2&gt;: &lt;执行2&gt; elif &lt;条件判断3&gt;: &lt;执行3&gt; else: &lt;执行4&gt; 循环 for...in... for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。 names = ['Michael', 'Bob', 'Tracy'] for name in names: print(name) range(101)生成0-100的整数序列. while循环 sum = 0 n = 99 while n &gt; 0: sum = sum + n n = n - 2 print(sum) dict与set dict在其他语言中Map对象。 总述： 列表 list[] 、元组 tuple() 、字典 dict{ key : value } 、无序不重复元素集合 set(list[]) ，后两者的key为不可变对象, 元组元素&quot;指向&quot;不可变。 对于 不变对象 来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。 重复元素在set中自动被过滤： &gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3]) &gt;&gt;&gt; s {1, 2, 3} 添加元素到set中: &gt;&gt;&gt; s.add(4) &gt;&gt;&gt; s {1, 2, 3, 4} &gt;&gt;&gt; s.add(4) &gt;&gt;&gt; s {1, 2, 3, 4} 删除元素： &gt;&gt;&gt; s.remove(4) &gt;&gt;&gt; s {1, 2, 3} set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： &gt;&gt;&gt; s1 = set([1, 2, 3]) &gt;&gt;&gt; s2 = set([2, 3, 4]) &gt;&gt;&gt; s1 &amp; s2 {2, 3} &gt;&gt;&gt; s1 | s2 {1, 2, 3, 4} 调用函数 max()函数可以接受任意多个参数, 并返回最大的数: &gt;&gt;&gt; max(1, 2) 2 &gt;&gt;&gt; max(2, 3, 1, -5) 3 定义函数 空函数 def nop(): pass pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来, 也可以放到其他语句中: if age &gt;= 18: pass 参数检查 数据类型检查可以用内置函数isinstance()实现： def my_abs(x): if not isinstance(x, (int, float)): raise TypeError('bad operand type') if x &gt;= 0: return x else: return -x 返回多个值 游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标： import math def move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny Python函数返回的仍然是单一值： &gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6) &gt;&gt;&gt; print(r) (151.96152422706632, 70.0) 函数的参数 明天 ","link":"https://foreup.github.io/post/0206-underscore-python/"},{"title":"0205-underscore","content":"underscore Collections map/filter 和Array的map()与filter()类似，但underscore的可以作用于Object。当作用于Object时，传入的函数为function (value, key)，第一个参数接收value，第二个参数接收key： 'use strict'; var obj = { name: 'bob', school: 'No.1 middle school', address: 'xueyuan road' }; var upper = _.map(obj, function (value, key) { return (key+': '+value); //[&quot;name: bob&quot;,&quot;school: No.1 middle school&quot;,&quot;address: xueyuan road&quot;] }); 对Object作map()操作的返回是Array, _.map换成_.mapObject返回为: {&quot;name&quot;:&quot;name: bob&quot;,&quot;school&quot;:&quot;school: No.1 middle school&quot;,&quot;address&quot;:&quot;address: xueyuan road&quot;} every / some 当集合的所有元素都满足条件时，_.every()函数返回true，当集合的至少一个元素满足条件时，_.some()函数返回true： 'use strict'; var obj = { name: 'bob', school: 'No.1 middle school', address: 'xueyuan road' }; // 判断key和value是否全部是小写： var r1 = _.every(obj, function (value, key) { return key===key.toLowerCase()&amp;&amp;value===value.toLowerCase(); }); var r2 = _.some(obj, function (value, key) { return key===key.toLowerCase()||value===value.toLowerCase(); }); max / min 直接返回集合中最大和最小的数, 若集合为Object时会忽略key只作用value. groupBy groupBy()把集合的元素按照key归类，key由传入的函数返回： 'use strict'; var scores = [20, 81, 75, 40, 91, 59, 77, 66, 72, 88, 99]; var groups = _.groupBy(scores, function (x) { if (x &lt; 60) { return 'C'; } else if (x &lt; 80) { return 'B'; } else { return 'A'; } }); // 结果: // { // A: [81, 91, 88, 99], // B: [75, 77, 66, 72], // C: [20, 40, 59] // } shuffle / sample shuffle()用洗牌算法随机打乱一个集合： 'use strict'; // 注意每次结果都不一样： _.shuffle([1, 2, 3, 4, 5, 6]); // [3, 5, 4, 6, 2, 1] sample()则是随机选择一个或多个元素： 'use strict'; // 注意每次结果都不一样： // 随机选1个： _.sample([1, 2, 3, 4, 5, 6]); // 2 // 随机选3个： _.sample([1, 2, 3, 4, 5, 6], 3); // [6, 1, 4] Arrays flatten flatten()接收一个Array，无论这个Array里面嵌套了多少个Array，flatten()最后都把它们变成一个一维数组： _.flatten([1, [2], [3, [[4], [5]]]]); // [1, 2, 3, 4, 5] zip / unzip zip()把两个或多个数组的所有元素按索引对齐，然后按索引合并成新数组。 'use strict'; var names = ['Adam', 'Lisa', 'Bart']; var scores = [85, 92, 59]; _.zip(names, scores); // [['Adam', 85], ['Lisa', 92], ['Bart', 59]] unzip()则是反过来： 'use strict'; var namesAndScores = [['Adam', 85], ['Lisa', 92], ['Bart', 59]]; _.unzip(namesAndScores); // [['Adam', 'Lisa', 'Bart'], [85, 92, 59]] object var names = ['Adam', 'Lisa', 'Bart']; var scores = [85, 92, 59]; _.object(names, scores); // {Adam: 85, Lisa: 92, Bart: 59} range 快速生成序列: 'use strict'; // 从0开始小于10: _.range(10); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] // 从1开始小于11： _.range(1, 11); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] // 从0开始小于30，步长5: _.range(0, 30, 5); // [0, 5, 10, 15, 20, 25] // 从0开始大于-10，步长-1: _.range(0, -10, -1); // [0, -1, -2, -3, -4, -5, -6, -7, -8, -9] uniq var arr = ['Apple', 'orange', 'banana', 'ORANGE', 'apple', 'PEAR']; var result = _.uniq(arr,function(x){return x.toUpperCase();}); //result:[&quot;Apple&quot;, &quot;orange&quot;, &quot;banana&quot;, &quot;PEAR&quot;] ","link":"https://foreup.github.io/post/0205-underscore/"},{"title":"0204-jQuery特定元素拓展","content":"jQ针对特定元素的拓展 假设用户调用:$('#main a').external(); &lt;!-- HTML结构 --&gt; &lt;div id=&quot;test-external&quot;&gt; &lt;p&gt;如何学习&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;？&lt;/p&gt; &lt;p&gt;首先，你要学习&lt;a href=&quot;/wiki/1022910821149312&quot;&gt;JavaScript&lt;/a&gt;，并了解基本的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt;。&lt;/p&gt; &lt;/div&gt; 则JS代码为: $.fn.external = function () { // return返回的each()返回结果，支持链式调用: return this.filter('a').each(function () { //filter可能需要改为find. // 注意: each()内部的回调函数的this绑定为DOM本身! var a = $(this); var url = a.attr('href'); if (url &amp;&amp; (url.indexOf('http://')===0 || url.indexOf('https://')===0)) { a.attr('href', '#0') .removeAttr('target') .append(' &lt;i class=&quot;uk-icon-external-link&quot;&gt;&lt;/i&gt;') .click(function () { if(confirm('你确定要前往' + url + '？')) { window.open(url); } }); } }); } ","link":"https://foreup.github.io/post/0204-jquery-te-ding-yuan-su-tuo-zhan/"},{"title":"0203-表单选择-动画-jQ拓展","content":"事件 鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave. 键盘事件 仅作用在当前焦点的DOM上，通常是&lt;input&gt;和&lt;textarea&gt; keydown：键盘按下时触发； keyup：键盘松开时触发； keypress：按一次键后触发. 其他事件 focus：当DOM获得焦点时触发； blur：当DOM失去焦点时触发； change：当&lt;input&gt;、&lt;select&gt;或&lt;textarea&gt;的内容改变时触发； submit：当&lt;form&gt;提交时触发； ready：当页面被载入并且DOM树完成初始化后触发. ready仅作用于document对象, 在DOM完成初始化后触发，且只触发一次，适合初始化代码. 简写 $(function () {...})的形式，牢记这是document对象的ready事件处理函数. 事件参数 如mousemove和keypress获取鼠标位置和按键的值, 所有事件都会传入Event对象作为参数, 可以从中获取更多信息: 获取鼠标位置: $(function () { $('#testMouseMoveDiv').mousemove(function (e) { $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY); }); }); 取消绑定 off('click', function) 其中function是函数名,匿名函数无法解绑, 可以试用off()解除所有绑定,off('click')解除所有的click事件绑定. function hello() { alert('hello!'); } a.click(hello); // 绑定事件 // 10秒钟后解除绑定: setTimeout(function () { a.off('click', hello); }, 10000); 安全限制 open(): 打开新窗口, 只能由用户触发的条件执行, 无法直接使用: var button1 = $('#testPopupButton1'); var button2 = $('#testPopupButton2'); function popupTestWindow() { window.open('/'); } button1.click(function () { popupTestWindow(); }); button2.click(function () { // 不立刻执行popupTestWindow()，3秒后执行: setTimeout(popupTestWindow, 3000); }); 事件练习 编写函数，绑定事件，实现表单项目的选择与全选操作： &lt;!-- HTML结构 --&gt; &lt;form id=&quot;test-form&quot; action=&quot;test&quot;&gt; &lt;legend&gt;请选择想要学习的编程语言：&lt;/legend&gt; &lt;fieldset&gt; &lt;p&gt;&lt;label class=&quot;selectAll&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; &lt;span class=&quot;selectAll&quot;&gt;全选&lt;/span&gt;&lt;span class=&quot;deselectAll&quot;&gt;全不选&lt;/span&gt;&lt;/label&gt; &lt;a href=&quot;#0&quot; class=&quot;invertSelect&quot;&gt;反选&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;lang&quot; value=&quot;javascript&quot;&gt; JavaScript&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;lang&quot; value=&quot;python&quot;&gt; Python&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;lang&quot; value=&quot;ruby&quot;&gt; Ruby&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;lang&quot; value=&quot;haskell&quot;&gt; Haskell&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;lang&quot; value=&quot;scheme&quot;&gt; Scheme&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;!--JS函数--&gt; &lt;script&gt; $(function () { let form = $('#test-form'), langs = form.find('[name=lang]'), selectAll = form.find('label.selectAll :checkbox'), selectAllLabel = form.find('label.selectAll span.selectAll'), deselectAllLabel = form.find('label.selectAll span.deselectAll'), invertSelect = form.find('a.invertSelect'); langs.change(); selectAll.change(function() { if(langs.get().every(e =&gt; e.checked)){ langs.prop('checked', false); } else{ langs.prop('checked', true); } langs.change(); }); langs.change(function() { if(langs.get().every(e =&gt; e.checked)){ selectAll.prop('checked', true); selectAllLabel.hide(); deselectAllLabel.show(); } else{ selectAll.prop('checked', false); deselectAllLabel.hide(); selectAllLabel.show(); } }); invertSelect.click(function(){ for(let x of langs){ console.log(x); x.checked = !x.checked; } langs.change(); }); }); &lt;/script&gt; 动画 jQuery动画的原理是逐渐改变CSS的值, 有的动画如slideUp(): height从100px逐渐变为0没有效果, 可能是因为很多不是block性质的DOM元素设置height没用. jQuery也没有实现对background-color的动画效果, 可以使用CSS3的transition. show/hide toggle()根据当前状态决定是show()还是hide(): toggle('slow') var div = $('#test-show-hide'); div.hide(3000); // 在3秒钟内逐渐消失 ***可以设置'slow''fast'字符串; var div = $('#test-show-hide'); div.show('slow'); // 在0.6秒钟内逐渐显示 slideUp / slideDown show()和hide()是从左上角逐渐展开或收缩, slideUp()和slideDown()是在垂直方向拉上或拉下； var div = $('#test-slide'); div.slideUp(3000); // 在3秒钟内逐渐向上消失 fadeIn / fadeOut 通过不断设置DOM元素的opacity属性实现, fadeToggle()根据元素当前状态决定; var div = $('#test-fade'); div.fadeOut('slow'); // 在0.6秒内淡出 自定义动画animate() var div = $('#test-animate'); div.animate({ opacity: 0.25, width: '256px', height: '256px' }, 3000); // 在3秒钟内CSS过渡到设定值 animate()传入一个函数，动画结束时，调用函数： ps: 回调函数参数对于基本动画也是适用的 var div = $('#test-animate'); div.animate({ opacity: 0.25, width: '256px', height: '256px' }, 3000, function () { console.log('动画已结束'); // 恢复至初始状态: $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px'); }); 串行动画 delay()用来暂停动画; var div = $('#test-animates'); // 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小 div.slideDown(2000) .delay(1000) .animate({ width: '256px', height: '256px' }, 2000) .delay(1000) .animate({ width: '128px', height: '128px' }, 2000); } 练习 制作remove()动画的渐隐效果: function deleteFirstTR() { var tr = $('#test-table&gt;tbody&gt;tr:visible').first(); tr.fadeOut(1000,function(){tr.remove();}); } deleteFirstTR(); AJAX **jQuery利用jsonp实现AJAX跨域访问简单示例: 1.创建HTML文件 &lt;html&gt; &lt;head&gt; &lt;title&gt;JSONP测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;刷新&quot; onclick=&quot;refreshPrice()&quot; /&gt; &lt;p&gt;当前价格:&lt;/p&gt; &lt;p id=&quot;current_price&quot;&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 2.引用jQuery &lt;script src=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; 3.js代码 &quot;use strict&quot; function refreshPrice() { let jqxhr = $.ajax('http://api.money.126.net/data/feed/0000001,1399001', { method: 'GET', dataType: 'jsonp', jsonp: 'callback', jsonpCallback: 'callbackFunction' }).done((data) =&gt; { let str = data['0000001'].name + ': ' + data['0000001'].price + '；' + data['1399001'].name + ': ' + data['1399001'].price; $('#current_price').slideUp('slow').text(str).slideDown('slow'); }).fail((xhr, status) =&gt; { alert('失败: ' + xhr.status + ', 原因: ' + status); }); } $(() =&gt; { refreshPrice(); }); jQuery拓展 编写jQuery插件 利用$.fn对象实现: $.fn.highlight1 = function () { // this已绑定为当前jQuery对象: this.css('backgroundColor', '#fffceb').css('color', '#d85030'); return this; //实现链式调用 } 简单加参数: $.fn.highlight2 = function (options) { // 要考虑到各种情况: // options为undefined // options只有部分key var bgcolor = options &amp;&amp; options.backgroundColor || '#fffceb'; var color = options &amp;&amp; options.color || '#d85030'; this.css('backgroundColor', bgcolor).css('color', color); return this; } 另一种用jQuery提供的辅助方法$.extend(target, obj1, obj2, ...)，把多个object对象的属性合并到第一个target对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高： // 把默认值和用户传入的options合并到对象{}中并返回: var opts = $.extend({}, { backgroundColor: '#00a8e6', color: '#ffffff' }, options); //最终版本的highlight $.fn.highlight = function (options) { // 合并默认值和用户设定值: var opts = $.extend({}, $.fn.highlight.defaults, options); this.css('backgroundColor', opts.backgroundColor).css('color', opts.color); return this; } // 设定默认值: $.fn.highlight.defaults = { color: '#d85030', backgroundColor: '#fff8de' } //用户设定默认值 $.fn.highlight.defaults.color = '#fff'; $.fn.highlight.defaults.backgroundColor = '#000'; ","link":"https://foreup.github.io/post/0203-biao-dan-xuan-ze-dong-hua-jq-tuo-zhan/"},{"title":"0202-jQuery事件","content":" val() .css() addClass('hightlight') removeClass attr() removeAttr a.hide() a.show() text() html() 操作DOM 修改text与html 使用text()和html(), 当无参数时获取节点内容,有参数时修改节点内容; JQuery获取的对象可以包含任意个节点, 调用.text()会修改对象内所有节点;(利用这点修改css) 修改css 使用.css('name', 'value')修改css属性如: background-color, color等, 是否有参数和text()的区别类似; var div = $('#test-div'); div.hasClass('highlight'); // false， class是否包含highlight div.addClass('highlight'); // 添加highlight这个class div.removeClass('highlight'); // 删除highlight这个class 显示隐藏DOM var a = $('a[target=_blank]'); a.hide(); // 隐藏 a.show(); // 显示 获取DOM信息 获取浏览器长宽属性 // 浏览器可视窗口大小: $(window).width(); // 800 // HTML文档大小: $(document).width(); // 800 // 某个div的大小: var div = $('#test-div'); div.width(); // 600 div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效 div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效 attr()和removeAttr()操作DOM节点属性; // &lt;div id=&quot;test-div&quot; name=&quot;Test&quot; start=&quot;1&quot;&gt;...&lt;/div&gt; var div = $('#test-div'); div.attr('data'); // undefined, 属性不存在 div.attr('name'); // 'Test' div.attr('name', 'Hello'); // div的name属性变为'Hello' div.removeAttr('name'); // 删除name属性 div.attr('name'); // undefined prop()与attr()方法: &lt;input id=&quot;test-radio&quot; type=&quot;radio&quot; name=&quot;test&quot; checked value=&quot;1&quot;&gt; 等价于： &lt;input id=&quot;test-radio&quot; type=&quot;radio&quot; name=&quot;test&quot; checked=&quot;checked&quot; value=&quot;1&quot;&gt; 所以: var radio = $('#test-radio'); radio.attr('checked'); // 'checked' radio.prop('checked'); // true prop()返回值更合理一些,用is()方法判断更好： 还有selected，处理时最好用is(':selected'); var radio = $('#test-radio'); radio.is(':checked'); // true 操作表单 jQuery对象统一提供val()方法获取和设置对应的value属性： /* &lt;input id=&quot;test-input&quot; name=&quot;email&quot; value=&quot;test&quot;&gt; &lt;select id=&quot;test-select&quot; name=&quot;city&quot;&gt; &lt;option value=&quot;BJ&quot; selected&gt;Beijing&lt;/option&gt; &lt;option value=&quot;SH&quot;&gt;Shanghai&lt;/option&gt; &lt;option value=&quot;SZ&quot;&gt;Shenzhen&lt;/option&gt; &lt;/select&gt; &lt;textarea id=&quot;test-textarea&quot;&gt;Hello&lt;/textarea&gt; */ var input = $('#test-input'), select = $('#test-select'), textarea = $('#test-textarea'); input.val(); // 'test' input.val('abc@example.com'); // 文本框的内容已变为abc@example.com select.val(); // 'BJ' select.val('SH'); // 选择框已变为Shanghai textarea.val(); // 'Hello' textarea.val('Hi'); // 文本区域已更新为'Hi' 修改DOM结构 添加与删除DOM 添加: 粗暴使用html()或使用append()添加至最后,prepend()将节点添加至最前; // 创建DOM对象: var ps = document.createElement('li'); ps.innerHTML = '&lt;span&gt;Pascal&lt;/span&gt;'; // 添加DOM对象: ul.append(ps); // 添加jQuery对象: ul.append($('#scheme')); // 添加函数对象: ul.append(function (index, html) { return '&lt;li&gt;&lt;span&gt;Language - ' + index + '&lt;/span&gt;&lt;/li&gt;'; }); 如果要添加的DOM节点已经存在于HTML文档中，它会首先从文档移除，然后再添加，用append()，可以移动一个DOM节点 ; 同级节点可以用after()或者before()确定插入位置: //先定位然后利用after()或before()插入节点; var js = $('#test-div&gt;ul&gt;li:first-child'); js.after('&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;'); 删除: var li = $('#test-div&gt;ul&gt;li'); li.remove(); // 所有&lt;li&gt;全被删除 练习对HTML元素排序 和0130的排序对照, 有部分相似 HTML结构: &lt;div id=&quot;test-div&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 用了两种方法,一是获取数组后排序再添加, 二是排序jQuery对象后直接添加; let arr = ['Pascal','Lua','Ruby']; let div = $('#test-div ul'); for(let x of arr){ div.append('&lt;li&gt;&lt;span&gt;'+x+'&lt;/span&gt;&lt;/li&gt;'); } let div2 = $('#test-div ul&gt;li'); let sort = Array.from(div2).map(x =&gt; x.innerText).sort(); //$('#test-div li').remove(); for(let x of sort){ div.append('&lt;li&gt;&lt;span&gt;'+x+'&lt;/span&gt;&lt;/li&gt;'); } console.log(sort); 等效于===&gt;&gt;： let arr = ['Pascal','Lua','Ruby']; let div = $('#test-div ul'); for(let x of arr){ div.append('&lt;li&gt;&lt;span&gt;'+x+'&lt;/span&gt;&lt;/li&gt;'); } let div2 = $('#test-div ul&gt;li'); let sort = div2.sort( (a,b) =&gt; a.innerText&gt;b.innerText? 1:-1 ); //$('#test-div li').remove(); append()会先从文档删除节点之后再添加； div.append(sort); ","link":"https://foreup.github.io/post/0202-jquery-shi-jian/"},{"title":"0201-Promise-JQuery选择","content":"Promise 最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败： resolve和reject分别代表成功与失败执行的函数； function test(resolve, reject) { var timeOut = Math.random() * 2; log('set timeout to: ' + timeOut + ' seconds.'); setTimeout(function () { if (timeOut &lt; 1) { log('call resolve()...'); resolve('200 OK'); //代表成功 } else { log('call reject()...'); reject('timeout in ' + timeOut + ' seconds.'); //代表失败 } }, timeOut * 1000); } 用一个Promise对象来执行上述函数，并根据设定的时间延迟显示结果； var p1 = new Promise(test); var p2 = p1.then(function (result) { console.log('成功：' + result); }).catch(function (reason) { console.log('失败：' + reason); }); Promise().then().then....catch() 多任务串行执行. Promise.all([p1,p2,...]) 多任务并行执行 都要成功才进入then,返回结果数组. Promise.race([p1,p2,...]) 多任务赛跑. then()和catch(),谁先调用算谁的,其它任务中断. Canvas 在HTML中设定一块画布的大小与ID等属性； 用JS在画图中绘画； var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); //矩形 ctx.fillStyle=&quot;#FF0000&quot;; ctx.fillRect(0,0,150,75); //路径 ctx.moveTo(0,0); //线条开始坐标 ctx.lineTo(200,100); //线条结束坐标 ctx.stroke(); //文本 ctx.font=&quot;30px Arial&quot;; //字体 ctx.fillText(&quot;Hello World&quot;,10,50); //实心字 ctx.strokeText(&quot;Hello World&quot;,10,50); //空心字 //画圆 ctx.beginPath(); ctx.arc(95,50,40,0,2*Math.PI); //x,y,r,start,stop ctx.stroke(); // ****创建渐变**** //createLinearGradient(x,y,x1,y1) - 创建线条渐变 //createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变 var grd=ctx.createLinearGradient(0,0,200,0); grd.addColorStop(0,&quot;red&quot;); grd.addColorStop(1,&quot;white&quot;); // 填充渐变 ctx.fillStyle=grd; ctx.fillRect(10,10,150,80); //图像 var img=document.getElementById(&quot;scream&quot;); ctx.drawImage(img,10,10); JQuery选择器 按ID查找 #abc以#开头，返回的对象是jQuery对象；如果id为abc的&lt;div&gt;存在：返回的JQuery对象为[&lt;div id=&quot;abc&quot;&gt;...&lt;/div&gt;]；若不存在：返回[]。 // 查找&lt;div id=&quot;abc&quot;&gt;: var div = $('#abc'); DOM与JQuery相互转化 var div = $('#abc'); // jQuery对象 var divDom = div.get(0); // 假设存在div，获取第1个DOM元素 var another = $(divDom); // 重新把DOM包装为jQuery对象 按tag查找 var ps = $('p'); // 返回所有&lt;p&gt;节点 ps.length; // 数一数页面有多少个&lt;p&gt;节点 按class查找 注意在class名称前加. var a = $('.red'); // 所有节点包含`class=&quot;red&quot;`都将返回 // 例如: // &lt;div class=&quot;red&quot;&gt;...&lt;/div&gt; // &lt;p class=&quot;green red&quot;&gt;...&lt;/p&gt; 查找class同时包含red和green的节点： var a = $('.red.green'); // 注意没有空格！ // 符合条件的节点： // &lt;div class=&quot;red green&quot;&gt;...&lt;/div&gt; // &lt;div class=&quot;blue green red&quot;&gt;...&lt;/div&gt; 按属性查找 当属性存在空格 等特殊字符时需要用双引号&quot;&quot;括起来； var email = $('[name=email]'); // 找出&lt;??? name=&quot;email&quot;&gt; var passwordInput = $('[type=password]'); // 找出&lt;??? type=&quot;password&quot;&gt; var a = $('[items=&quot;A B&quot;]'); // 找出&lt;??? items=&quot;A B&quot;&gt; 属性的前缀后缀查找 var icons = $('[name^=icon]'); // 找出所有name属性值以icon开头的DOM // 例如: name=&quot;icon-1&quot;, name=&quot;icon-2&quot; var names = $('[name$=with]'); // 找出所有name属性值以with结尾的DOM // 例如: name=&quot;startswith&quot;, name=&quot;endswith&quot; var icons = $('[class^=&quot;icon-&quot;]'); // 找出所有class包含至少一个以`icon-`开头的DOM // 例如: class=&quot;icon-clock&quot;, class=&quot;abc icon-home&quot; 组合查找 var emailInput = $('input[name=email]'); // 不会找出&lt;div name=&quot;email&quot;&gt;, 只查找&lt;input&gt;标签 //tag和class组合查找 var tr = $('tr.red'); // 找出&lt;tr class=&quot;red ...&quot;&gt;...&lt;/tr&gt; 多项选择器 选出的元素按在HTML中的顺序排序，且不会有重复元素； &lt;p class=&quot;red green&quot;&gt;不会被下面的$('p.red,p.green')选择两次； $('p,div'); // 把&lt;p&gt;和&lt;div&gt;都选出来 $('p.red,p.green'); // 把&lt;p class=&quot;red&quot;&gt;和&lt;p class=&quot;green&quot;&gt;都选出来 以下内容以此为例 &lt;!-- HTML结构 --&gt; &lt;div class=&quot;testing&quot;&gt; &lt;ul class=&quot;lang&quot;&gt; &lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt; &lt;li class=&quot;lang-python&quot;&gt;Python&lt;/li&gt; &lt;li class=&quot;lang-lua&quot;&gt;Lua&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 层级选择器 用$('ancestor descendant')来选择，层级之间用空格隔开； $('ul.lang li.lang-javascript'); // [&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;] $('div.testing li.lang-javascript'); // [&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;] 选择所有的&lt;li&gt;节点： $('ul.lang li'); $('form[name=upload] input'); //选择范围限定在name属性为upload的表单里 $('form.test p input'); // 多层选择,在form表单选择被&lt;p&gt;包含的&lt;input&gt; 子选择器 $('parent&gt;child')类似层级选择器，但必须是直系父子关系； $('ul.lang&gt;li.lang-javascript'); // 可以选出[&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;] $('div.testing&gt;li.lang-javascript'); // [], 无法选出，因为&lt;div&gt;和&lt;li&gt;不构成父子关系 过滤器 $('ul.lang li'); // 选出JavaScript、Python和Lua 3个节点 $('ul.lang li:first-child'); // 仅选出JavaScript $('ul.lang li:last-child'); // 仅选出Lua $('ul.lang li:nth-child(2)'); // 选出第N个元素，N从1开始 $('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素 $('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素 查找和过滤 查找 获得一个节点ul ul.find()节点内查找 &lt;!-- HTML结构 --&gt; &lt;ul class=&quot;lang&quot;&gt; &lt;li class=&quot;js dy&quot;&gt;JavaScript&lt;/li&gt; &lt;li class=&quot;dy&quot;&gt;Python&lt;/li&gt; &lt;li id=&quot;swift&quot;&gt;Swift&lt;/li&gt; &lt;li class=&quot;dy&quot;&gt;Scheme&lt;/li&gt; &lt;li name=&quot;haskell&quot;&gt;Haskell&lt;/li&gt; &lt;/ul&gt; find()查找： var ul = $('ul.lang'); // 获得&lt;ul&gt; var dy = ul.find('.dy'); // 获得JavaScript, Python, Scheme var swf = ul.find('#swift'); // 获得Swift var hsk = ul.find('[name=haskell]'); // 获得Haskell 向上查找，使用parent()： var swf = $('#swift'); // 获得Swift var parent = swf.parent(); // 获得Swift的上层节点&lt;ul&gt; var a = swf.parent('.red'); // 获得Swift的上层节点&lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空jQuery对象 同一层级的节点，可以使用next()和prev()方法： var swift = $('#swift'); swift.next(); // Scheme swift.next('[name=haskell]'); // 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell] swift.prev(); // Python swift.prev('.dy'); // Python，因为Python同时符合过滤器条件.dy 过滤 和函数的map、filter类似： filter()过滤掉不符合条件的节点； var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell var a = langs.filter('.dy'); // 拿到JavaScript, Python, Scheme 或者也可以传入函数，注意this的指向的对象为DOM var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell langs.filter(function () { return this.innerHTML.indexOf('S') === 0; // 返回S开头的节点 }); // 拿到Swift, Scheme map()把JQuery对象中的节点转化为数组或其他形式 var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell var arr = langs.map(function () { return this.innerHTML; }).get(); // 用get()拿到包含string的Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell'] 若JQuery包含多个节点，可以用first()、last()、slice()返回新的JQuery对象，删除不必要节点； var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell var js = langs.first(); // JavaScript，相当于$('ul.lang li:first-child') var haskell = langs.last(); // Haskell, 相当于$('ul.lang li:last-child') var sub = langs.slice(2, 4); // Swift, Scheme, 参数和数组的slice()方法一致 练习 对于下面表单，输入值后，用jQuery获取表单的JSON字符串，key和value分别对应每个输入的name和相应的value，例如：{&quot;name&quot;:&quot;Michael&quot;,&quot;email&quot;:...} &lt;form id=&quot;test-form&quot; action=&quot;#0&quot; onsubmit=&quot;return false;&quot;&gt; &lt;p&gt;&lt;label&gt;Name: &lt;input name=&quot;name&quot;&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;Email: &lt;input name=&quot;email&quot;&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;Gender: &lt;label&gt;&lt;input name=&quot;gender&quot; type=&quot;radio&quot; value=&quot;m&quot; checked&gt; Male&lt;/label&gt; &lt;label&gt;&lt;input name=&quot;gender&quot; type=&quot;radio&quot; value=&quot;f&quot;&gt; Female&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;City: &lt;select name=&quot;city&quot;&gt; &lt;option value=&quot;BJ&quot; selected&gt;Beijing&lt;/option&gt; &lt;option value=&quot;SH&quot;&gt;Shanghai&lt;/option&gt; &lt;option value=&quot;CD&quot;&gt;Chengdu&lt;/option&gt; &lt;option value=&quot;XM&quot;&gt;Xiamen&lt;/option&gt; &lt;/select&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt; &lt;/form&gt; &lt;!--****JS脚本****--&gt; &lt;script&gt; json = {}; //将json初始化为对象 // 利用和表单元素相关的特殊选择器 // 理解filter和map的机制 let tmp1 = $('#test-form :input').not('button').filter(function(){ //console.log(this.type); return this.type !== 'radio' || this.checked; }).map(function(){ json[this.name] = this.value; return true; }); json = JSON.stringify(json); &lt;/script&gt; ","link":"https://foreup.github.io/post/0201-promise-jquery-xuan-ze/"},{"title":"0131-DOM-文件-AJAX","content":"删除DOM 删除后子节点不在文档树中，但仍在内存中，可随时将其放到其他地方； var willBeRemoved = document.getElementById(test-id); var beRemovedParent = willBeRemoved.parentElement; var removed = beRemovedParent.removeChild(willBeRemoved); removed === willBeRemoved; //true; ps：要注意，children属性是一个只读属性，删除多个节点时，要注意children属性时刻都在变化； 练习删除Web开发不相关的节点 let prt = document.getElementById('test-list'); let removeArr = ['JavaScript','HTML','CSS']; Array.from(prt.children).forEach(function(x){removeArr.includes(x.innerText)? x : prt.removeChild(x);}); [\\S]查找非空白字符； 注册信息验证练习： &lt;!-- HTML结构 --&gt; &lt;form id=&quot;test-register&quot; action=&quot;#&quot; target=&quot;_blank&quot; onsubmit=&quot;return checkRegisterForm()&quot;&gt; &lt;p id=&quot;test-error&quot; style=&quot;color:red&quot;&gt;&lt;/p&gt; &lt;p&gt; 用户名: &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/p&gt; &lt;p&gt; 口令: &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/p&gt; &lt;p&gt; 重复口令: &lt;input type=&quot;password&quot; id=&quot;password-2&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt; &lt;/p&gt; &lt;/form&gt; &lt;!-- JavaScript 内容 --&gt; &lt;script&gt; var checkRegisterForm = function () { let usc = 0, psc = 0, in_us = document.getElementById('username'), in_ps = document.getElementById('password'), in_ps2 = document.getElementById('password-2'); let usexp = /[0-9a-zA-Z]{3,10}/, psexp = /[\\S]{6,20}/; if(usexp.test(in_us.value)) {usc += 1;} if(!usexp.test(in_us.value)) {window.alert('用户名必须是3-10位英文字母或数字；'); return false;} if(psexp.test(in_ps.value)){psc += 1;} if(!psexp.test(in_ps.value)) {window.alert('口令必须是6-20位；'); return false;} if(in_ps.value!==in_ps2.value) {psc--; window.alert('两次口令必须一致；'); return false;} return usc&amp;&amp;psc; } &lt;/script&gt; 操作文件 以预览图片为例 &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt;图片预览：&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;div id=&quot;test-image-preview&quot; style=&quot;border: 3px solid #ff0000; border-radius: 10px; width: 33%; height: 200px; background-size: contain; background-repeat: no-repeat; background-position: center center;&quot;&gt; &lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; id=&quot;test-image-file&quot; name=&quot;test&quot;&gt; &lt;/p&gt; &lt;p id=&quot;test-file-info&quot;&gt;没有选择文件&lt;/p&gt; &lt;/form&gt; js代码及说明 FileReader()对象用来读取文件； element.target.result将图片编码为base64数据； preview.style.backgroundImage = 'url(' + data + ')';显示图片； //确定js在HTML后加载 window.onload = function() { var fileInput = document.getElementById('test-image-file'), info = document.getElementById('test-file-info'), preview = document.getElementById('test-image-preview'); // 监听change事件: fileInput.addEventListener(&quot;change&quot;, previewFunc); function previewFunc () { // 清除背景图片: preview.style.backgroundImage = ''; // 检查文件是否选择: if (!fileInput.value) { info.innerHTML = '没有选择文件'; return; } // 获取File引用: var file = fileInput.files[0]; // 获取File信息: info.innerHTML = '文件: ' + file.name + '&lt;br&gt;' + '大小: ' + file.size + '&lt;br&gt;' + '修改: ' + file.lastModified; if (file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif') { alert('不是有效的图片文件!'); return; } // 读取文件: var reader = new FileReader(); reader.onload = function(e) { var data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage = 'url(' + data + ')'; console.log(data); }; // 以DataURL的形式读取文件: reader.readAsDataURL(file); } } //确定js在HTML后加载 AJAX入门 var xhttp = new XMLHttpRequest();创建xhttp为名的XMLHttpRequest的对象； xhttp.onreadystatechange = function() { ... }当XMLHttpRequest的状态改变时回调函数； xmlhttp.readyState： 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 xmlhttp.status： 200: &quot;OK&quot; 404: 未找到页面 xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/gethint.php?q=&quot;+str,true); xmlhttp.send(); open(method,url,async)使readyState改变： method：请求的类型；GET 或 POST，大小写均可； ","link":"https://foreup.github.io/post/0131-dom-wen-jian-ajax/"},{"title":"0130-继承-DOM-HTML排序","content":"原型继承 创建新函数，并使用call()绑定this； 使用空函数new F()指向父原型； 修复子原型的constructor为子原型； 尽量将封装一个inherits函数实现继承； 例子 function inherits(Child, Parent) { var F = function () {}; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; } 通过inherits继承原型 function Student(props) { this.name = props.name || 'Unnamed'; } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); } function PrimaryStudent(props) { Student.call(this, props); this.grade = props.grade || 1; } // 实现原型继承链: inherits(PrimaryStudent, Student); // 绑定其他方法到PrimaryStudent原型: PrimaryStudent.prototype.getGrade = function () { return this.grade; }; ES6新增的class可以使原型的继承更为简单 //父对象模型 class Student { constructor(name) { this.name = name; } hello() { alert('Hello, ' + this.name + '!'); } } //新建对象 var xiaoming = new Student('小明'); xiaoming.hello(); //子对象模型 class PrimaryStudent extends Student { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert('I am at grade ' + this.grade); } } DOM选择相关 document.getElementById() //具有唯一性 document.getElementsByTagName() //不具有唯一性，返回一组DOM节点 document.getElementsByClassName() //不具有唯一性 // 先定位ID为'test-table'的节点，再返回其内部所有tr节点： var trs = document.getElementById('test-table').getElementsByTagName('tr'); // 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点： var reds = document.getElementById('test-div').getElementsByClassName('red'); // 获取节点test下的所有直属子节点: var cs = test.children; // 获取节点test下第一个、最后一个子节点： var first = test.firstElementChild; var last = test.lastElementChild; // 通过querySelector获取ID为q1的节点： var q1 = document.querySelector('#q1'); // 通过querySelectorAll获取q1节点内的符合条件的所有节点： var ps = q1.querySelectorAll('div.highlighted &gt; p'); //练习，评论区回答 var arr = document.querySelectorAll('.c-red.c-green&gt;p'); var arr = document.getElementsByClassName('c-red c-green')[0].children; var arr = document.querySelectorAll(&quot;.c-red.c-green p&quot;); // 选择&lt;p&gt;Haskell&lt;/p&gt;: var haskell = document.querySelector(&quot;#test-div div:last-child p:last-child&quot;); p.innerHTML = 'ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ'; p.innerText = 'ABC'; // 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt; var p = document.getElementById('p-id'); // 设置CSS: p.style.color = '#ff0000'; p.style.fontSize = '20px'; p.style.paddingTop = '2em'; 插入DOM 插入最后 DOM节点为空，如，&lt;div&gt;&lt;/div&gt;，使用innerHTML = '&lt;span&gt;child&lt;/span&gt;'插入新的子节点，但会覆盖原来的子节点； 若非空，则可以用appendChild把一个子节点添加到父节点的最后一个子节点。 原结构： &lt;!-- HTML结构 --&gt; &lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt; &lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt; &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt; &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt; &lt;/div&gt; 把&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;添加到&lt;div id=&quot;list&quot;&gt;的最后一项： var js = document.getElementById('js'), list = document.getElementById('list'); list.appendChild(js); 修改后的结构： &lt;!-- HTML结构 --&gt; &lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt; &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt; &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt; &lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt; &lt;/div&gt; 上面是把之前存在的节点移动到新位置，更多需要新建节点，应该如下： 新语句： document.createElement('p');——创建元素； d.setAttribute('type', 'text/css');——设置对象属性； var list = document.getElementById('list'), haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.appendChild(haskell); var d = document.createElement('style'); d.setAttribute('type', 'text/css'); d.innerHTML = 'p { color: red }'; //‘p’用来确定是&lt;p&gt;还是其他，如&lt;h1&gt;等； document.getElementsByTagName('head')[0].appendChild(d); 插入指定位置 使用parentElement.insertBefore(newElement, referenceElement);，插入到referenceElement之前 &lt;!-- HTML结构 --&gt; &lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt; &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt; &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var list = document.getElementById('list'), ref = document.getElementById('python'), haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.insertBefore(haskell, ref); &lt;/script&gt; &lt;!-- *新* HTML结构 --&gt; &lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt; &lt;p id=&quot;haskell&quot;&gt;Haskell&lt;/p&gt; &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt; &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt; &lt;/div&gt; 循环一个父节点的所有子节点，可以通过迭代children属性实现将所有子节点写入某数组中； 复习下面的代码： &lt;!-- HTML结构 --&gt; &lt;ol id=&quot;test-list&quot;&gt; &lt;li class=&quot;lang&quot;&gt;Scheme&lt;/li&gt; &lt;li class=&quot;lang&quot;&gt;JavaScript&lt;/li&gt; &lt;li class=&quot;lang&quot;&gt;Python&lt;/li&gt; &lt;li class=&quot;lang&quot;&gt;Ruby&lt;/li&gt; &lt;li class=&quot;lang&quot;&gt;Haskell&lt;/li&gt; &lt;/ol&gt; 对HTML内容排序 //直接排序 list = document.getElementById('test-list'); sort = Array.from(list.children).sort((a, b) =&gt; a.innerText &gt; b.innerText ? 1:-1); for (let e of sort) list.appendChild(e); //获取文本排序后返回 list = Array.from(document.getElementById('test-list').children); sort = list.map(element =&gt; element.innerText).sort(); list.map((element, index) =&gt; element.innerText = sort[index]) //自己最开始写的笨方法 let c = []; let pz = document.getElementById('test-list'); for(let i = 0; i &lt; pz.children.length; i++){ c[i] = pz.children[i].innerText; } let s = c.sort(); let ht; for (x of s){ ht = ht + '&lt;li class=&quot;lang&quot;&gt;' + x +'&lt;/li&gt;' + &quot; &quot;; } ","link":"https://foreup.github.io/post/0130-dom-html-pai-xu/"},{"title":"0129小结","content":"大纲 filter去重 filter筛选数组中素数 sort()函数复习 Array对象 函数闭包 箭头函数 generator对象 正则表达与Date对象 Jason filter去重 var r, arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry']; r = arr.filter(function (element, index, self) { return self.indexOf(element) === index;}); //PS:element, index, self只是形式？不知道能不能换！ filter筛选素数 简单的方法可以考虑素数只有1和本身两个因数，麻烦的可以依据定义写函数 //获得素数函数，可以利用素数只有两个因数，下面的是麻烦的，从定义写的函数！ function get_primes(arr) { var brr = arr.filter(function(ss){ var jsw = 0; if (ss == 1) {jsw =1} else { for (var i=2; i&lt;ss; i++) { if( ss%i==0 ){ jsw = jsw +1; break;} else{ continue; } } } return !jsw; }); return brr; } //依据因数是否只有2个 arr = arr.filter(function(element, index, self){ var count = 0;//记录因数的数量 for(var i=1;i&lt;=element;i++){ if(element%i===0){ count++; } } if(element===1){ return false; } return count&lt;3; }); console.log(arr) sort函数 在3w网站学过，快速排序，按照-1,0,1的顺序，也可以排列有属性的对象 //数字小-&gt;大排序； points.sort(function(a, b){return a - b}); //随机排序数组； points.sort(function(a, b){return 0.5 - Math.random()}); //排序有属性数组,按照字母排序对象 cars.sort(function(a, b){return a.year - b.year});； function myFunction() { var cars = [{type:&quot;BMW&quot;, year:2017},{type:&quot;Audi&quot;, year:2019},{type:&quot;porsche&quot;, year:2018}]; cars.sort(function(a, b){ var x = a.type.toLowerCase(); var y = b.type.toLowerCase(); if (x &lt; y) {return -1;} if (x &gt; y) {return 1;} return 0; }); displayCars(); } Array every var arr = ['Apple', 'pear', 'orange']; console.log(arr.every(function (s) { return s.length &gt; 0; })); // true, 因为每个元素都满足s.length&gt;0 find 查找符合条件的第一个元素，如果找到了，返回这个元素；否则返回undefined var arr = ['Apple', 'pear', 'orange']; console.log(arr.find(function (s) { return s.toLowerCase() === s; })); // 'pear', 因为pear全部是小写 findIndex 和find类似，区别：findIndex()会返回这个元素的索引，如果没有找到，返回-1; forEach forEach()和map()类似，但不会返回新数组; 函数闭包 把函数作为结果值返回，返回函数不要引用任何循环变量，或者后续会发生变化的变量：再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push((function (n) { return function () { return n * n; } })(i)); } return arr; } var results = count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; f1(); // 1 f2(); // 4 f3(); // 9 用了一个“创建一个匿名函数并立刻执行”的语法： (function (x) { return x * x; })(3); // 9 只有函数的语言里，借助闭包，可以封装一个私有变量。我们用JavaScript创建一个计数器： 'use strict'; function create_counter(initial) { var x = initial || 0; return { inc: function () { x += 1; return x; } } } 使用： var c1 = create_counter(); c1.inc(); // 1 c1.inc(); // 2 c1.inc(); // 3 var c2 = create_counter(10); c2.inc(); // 11 c2.inc(); // 12 c2.inc(); // 13 闭包可以把多参数的函数变成单参数的函数: function make_pow(n) { return function (x) { return Math.pow(x, n); } } // 创建两个新函数: var pow2 = make_pow(2); var pow3 = make_pow(3); console.log(pow2(5)); // 25 console.log(pow3(7)); // 343 箭头函数 this的指向与标准function不同，始终指向词法作用域(还是挺糊涂的，以后遇到实例再说吧)； var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = function () { return new Date().getFullYear() - this.birth; // this指向window或undefined }; return fn(); } }; 箭头函数修复了this的指向 var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); } }; obj.getAge(); // 25 generator generator由function*定义，可以用yield多次返回，也可以和函数一样用return返回一次。 function* fib2(max){ var a=0, b=1, t; for (var i = 0; i&lt;max; i++) { t=a; //也可以直接执行 yield a; [a,b]=[b,a+b]; yield t; } } //generator的调用，有两种方式 for (var shc of fib2(5)){ console.log(shc); } 也可以用next()调用； var f = fib(5); f.next(); // {value: 0, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 2, done: false} f.next(); // {value: 3, done: false} f.next(); // {value: undefined, done: true} 学了AJAX以后可以体会到generator更大的好处，目前只知道可以保存函数的中间状态； RegExp相关 基本知识 \\w可以匹配一个字母或数字，\\d匹配一个数字； +表示至少一个字符：\\s+表示至少有一个空格； *表示任意个字符，?表示0个或1个字符； \\d{3,8}表示3-8个数字，如'1234567'等； 匹配'010-12345'，-是特殊字符，需要转义，所以号码的正则是\\d{3}\\-\\d{3,8}； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*表示由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串； A|B可以匹配A或B：(J|j)ava(S|s)cript； ^表示行的开头，^\\d必须以数字开头； $表示行的结束，\\d$必须以数字结束：js也可以匹配jsp，但js$只能匹配js; 创建正则表达式： var re1 = /ABC\\-001/; var re2 = new RegExp('ABC\\\\-001'); re1; // /ABC\\-001/ re2; // /ABC\\-001/ 切分字符串 'a b c'.split(' '); // ['a', 'b', '', '', 'c']; 'a b c'.split(/\\s+/); // ['a', 'b', 'c']; 'a,b, c d'.split(/[\\s\\,]+/); // ['a', 'b', 'c', 'd']; //至少一个[' '或','或';'] 'a,b;; c d'.split(/[\\s\\,\\;]+/); // ['a', 'b', 'c', 'd']; 分组 除了匹配外，正则还可以提取字符串，()表示的就是要提取的分组； //先匹配字符串 var re = /^(\\d{3})-(\\d{3,8})$/; re.exec('010-12345'); // ['010-12345', '010', '12345'] re.exec('010 12345'); // null exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串；失败则会返回null。 var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/; re.exec('19:05:30'); // ['19:05:30', '19', '05', '30'] 上述可以识别合法日期。 但是对于日期的识别可能会出问题： var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/; 对于'2-30'，'4-31'非法日期正则很难去识别，需要程序实现； 贪婪匹配：正则默认贪婪匹配 var re = /^(\\d+)(0*)$/; re.exec('102300'); // ['102300', '102300', ''] 导致0*无法匹配到字符串，可以加个？来解决(尽可能少匹配)： var re = /^(\\d+?)(0*)$/; re.exec('102300'); // ['102300', '1023', '00'] 全局匹配 g，表示全局匹配；i，表示忽略大小写；m，表示多行匹配。 var r1 = /test/g; // 等价于: var r2 = new RegExp('test', 'g'); 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串，指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引： var s = 'JavaScript, VBScript, JScript and ECMAScript'; var re=/[a-zA-Z]+Script/g; // 使用全局匹配: re.exec(s); // ['JavaScript'] re.lastIndex; // 10 re.exec(s); // ['VBScript'] re.lastIndex; // 20 re.exec(s); // ['JScript'] re.lastIndex; // 29 re.exec(s); // ['ECMAScript'] re.lastIndex; // 44 re.exec(s); // null，直到结束仍没有匹配到 全局匹配不能使用不能使用/^...$/ Jason学习 学习中看了篇评论区文章，箭头函数不乱用，箭头函数本身无this、arguments等属性，使用箭头函数一定要在外层套一层函数，使this在可见范围内，对象无法分割作用域（对象内的箭头函数无法确定this的指向），定义变量const&gt;let&gt;var尽量依次使用。 创建对象 通过函数创建对象，理解还较浅，注意prototype与__proto__以及原型链 function Cat(name) { this.name = name; } Cat.prototype.say = function(){ return 'Hello, ' + this.name + '!'; } 可以用一个createStudent来内部封装new function Student(props) { this.name = props.name || '匿名'; this.grade = props.grade || 1; } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); } function createStudent(props) { return new Student(props || {}) } createStudent的参数非常灵活，可以不传也可以如下： var xiaoming = createStudent({ name: '小明' }); xiaoming.grade; ","link":"https://foreup.github.io/post/0129-xiao-jie/"},{"title":"0128小结","content":"看完了w3school JS教程发现教程太长，太啰嗦了，太基础了，各种重复，因此打算去**廖雪峰** 那学，过几天看看效果吧，下面看看今天在 w3那总结的东西： &lt;script&gt; myarray.foreach() function myFunction(value, index, array) { txt = txt + value + &quot;&lt;br&gt;&quot;; } //value:项目值，index：索引，array：数组本身； myarray.map() //对每个元素执行函数创建新数组，不会对没有值元素执行，不改变原来数组； numbers.reduce(function1,100) // return total + value; total 总数（初始值/先前返回的值）,可定义一个初始值, reduceRight() var over18 = numbers.filter(myFunction); //function{ return value &gt;18 ; },创建通过测试的新数组； numbers.every() //方法检查所有数组值是否通过测试,some()检查某些数组值. mynum.find() //方法返回通过测试函数的第一个数组元素的值,findIndex()返回索引； -----'日期'------ new Date(2018, 11, 24, 10, 33, 30); //年、月、日、小时、分钟、秒,0为一月； var d = new Date(&quot;October 13, 2014 11:13:00&quot;); //日期存储为自 1970 年 1 月 1 日 00:00:00 UTC以来的毫秒数; document.getElementById(&quot;demo&quot;).innerHTML = d; //d为日期对象，会使用 toString()自动转换为字符串； d.toUTCString(); d.toDateString(); //转换为易读的日期字符串 ISO日期格式：&quot;2018-02-19&quot; （国际标准），严格符合JS标准 new Date(&quot;2019&quot;); 与 new Date(2019); 不同； 短日期通常使用 &quot;MM/DD/YYYY&quot; 格式； var d = new Date(); d.getDate() 以数值返回天（1-31） d.getUTCDate() d.getDay() 以数值获取周名（0-6） d.getFullYear() 获取四位的年（yyyy） d.getHours() 获取小时（0-23） d.getMilliseconds() 获取毫秒（0-999） d.getMinutes() 获取分（0-59） d.getMonth() 获取月（0-11） d.getSeconds() 获取秒（0-59） d.getTime() 获取时间（从 1970 年 1 月 1 日至今的毫秒数） -----'数学'------ Math.round(x) 返回 x 四舍五入为最接近的整数； Math.pow(x, y) 返回 x 的 y 次幂； Math.sqrt(x) 返回 x 的平方根； Math.ceil(x) 返回 x '上舍入' 最接近的整数 Math.floor(x) '下舍入' Math.sin(x) 返回角 x弧度 的正弦 &lt;/script&gt; &lt;script&gt; var add = (function () { var counter = 0; return function () {counter += 1; return counter;} })(); function myFunction(){ document.getElementById(&quot;demo&quot;).innerHTML = add(); } &lt;/script&gt; 廖雪峰中个人认为有用的练习 2.不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数 &lt;script&gt; var s = '123456789'; var arr = []; for( var a of s ){ arr.push(a) } console.log(arr); //ASCII码，数字字符的ASCII码 - '0'的ASCII码值 = 数字字符的数值 //var brr = arr.map(function(x){ return x - '0' ;}); var brr = arr.map(function(x){ return x * 1;}); console.log(brr); //转换为整数 var c = brr.reduce(function(x,y){ return x * 10 + y; }); console.log(c); &lt;/script&gt; 3.把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字 &lt;script&gt; var arr = ['adam', 'LISA', 'barT']; var l3arr = arr.map(function(x){return x[0].toUpperCase()+x.slice(1).toLowerCase();}); console.log(l3arr); &lt;/script&gt; ","link":"https://foreup.github.io/post/0128-xiao-jie/"},{"title":"0127学习笔记","content":"&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;学过的语法记录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;&quot;&gt; /*onchange HTML 元素已被改变 onclick 用户点击了 HTML 元素 onmouseover 用户把鼠标移动到 HTML 元素上 onmouseout 用户把鼠标移开 HTML 元素 onkeydown 用户按下键盘按键 onload 浏览器已经完成页面加载*/ concat() indexOf() lastIndexOf() /*搜索字符串*/ search() slice() substring() substr() -------------- replace() toUpperCase() toLowerCase() mystring.trim() -------------- 提取字符串 charAt() //返回字母 charCodeAt() // 返回编码值 str[0]; // str = &quot;HELLO WORLD&quot;，返回 H； text.match(/ain/g) // 返回数组 [ain,ain,ain] text.match(/ain/gi) // 返回数组 [ain,AIN,ain,ain] string.includes(searchvalue, start) //start 起始位置可选 text.includes(&quot;world&quot;) // 返回 true string.startsWith(searchvalue, start) text.startsWith(&quot;Hello&quot;) // 字符串以Hello开头，返回 true text.endsWith(&quot;Doe&quot;, 5) // 返回 true let text = &quot;Bill Gates&quot;; text.endsWith(&quot;Gates&quot;,10); //指定长度后必须严格和长度一致，9或11均为 false /*模板字面量*/ let text = `He's often called &quot;Johnny&quot;`; //反引号允许多行字符串 let text = `The quick the lazy dog`; let firstName = &quot;John&quot;; text = `Welcome ${firstName}!`; //字符串插值（string interpolation）,变量和表达式插入字符串 total = `Total: ${(price * (1 + VAT)).toFixed(3)}`; //price=10，VAT=0.25,； let html = `&lt;h2&gt;${header}&lt;/h2&gt;&lt;ul&gt;`; //HTML模板，具体例子太长； isNaN(x); // 返回 true，因为 x 不是数； typeof Infinity; //返回number，是超出计算的数字； 0x; //解释为16进制； number.toString(16); // 返回 80，toString()以字符串形式输出为指定进制，默认10； x.toExponential(2); //（）内为小数点后位数； mynum.toFixed(num); //num确定保留以四舍五入保留几位小数； toPrecision() 返回字符串值，指定长度的'数字' new Number(500); //不要用new定义对象，JS中对象无法进行比较； valueOf() //以数值返回数值 Number() parseInt() parseFloat() MAX_VALUE ; MIN_VALUE; 对变量、表达式或值使用数字属性，将返回 undefined; ----/数组方法/---- Array.foreach() //遍历数组 fruits.push(&quot;Lemon&quot;); // 向 fruits 添加一个新元素 (Lemon)，返回字符串长度，使用高索引添加会增加“洞/undefined” pop() //从数组中弹出元素，返回弹出的值； shift() //从首部移出元素 unshift() //从首部增加元素 delete fruits[0]; // 把 fruits 中的首个元素改为 undefined,尽量不用 myarray.toString() //把数组转换为数组值（逗号分隔）的字符串 myarray.join() //可以规定结合成为字符串的分割符 fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;); //第二个参数（0）定义应删除多少元素,返回一个包含已删除项的数组 fruits.splice(0, 1); // 删除 fruits 中的第一个元素 fruits.slice() //用fruits的某个片段切出新数组,不删除改变fruits，start位置(,end位置)； fruits.sort() //方法是最强大的数组方法之一,按字母排序； points.sort(function(a, b){return a - b}); //数字小-&gt;大排序； points.sort(function(a, b){return 0.5 - Math.random()}); //随机排序数组； Math.max(1, 2, 3); Math.min(1, 2, 3); cars.sort(function(a, b){return a.year - b.year}); //排序有属性数组； &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://foreup.github.io/post/0127-xue-xi-bi-ji/"},{"title":"Github Pages与GRidea搭建静态博客","content":"说不清的辛酸与累啊，以后看情况更新今天所经历的挫折吧！ FLAG：每日一篇总结性文章（包括前端学习、C++学习等） ","link":"https://foreup.github.io/post/github-pages-yu-gridea-da-jian-jing-tai-bo-ke/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://foreup.github.io/post/hello-gridea/"}]}