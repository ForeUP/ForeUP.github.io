{"posts":[{"title":"0131-DOM-文件-AJAX","content":"删除DOM 删除后子节点不在文档树中，但仍在内存中，可随时将其放到其他地方； var willBeRemoved = document.getElementById(test-id); var beRemovedParent = willBeRemoved.parentElement; var removed = beRemovedParent.removeChild(willBeRemoved); removed === willBeRemoved; //true; ps：要注意，children属性是一个只读属性，删除多个节点时，要注意children属性时刻都在变化； 练习删除Web开发不相关的节点 let prt = document.getElementById('test-list'); let removeArr = ['JavaScript','HTML','CSS']; Array.from(prt.children).forEach(function(x){removeArr.includes(x.innerText)? x : prt.removeChild(x);}); [\\S]查找非空白字符； 注册信息验证练习： &lt;!-- HTML结构 --&gt; &lt;form id=&quot;test-register&quot; action=&quot;#&quot; target=&quot;_blank&quot; onsubmit=&quot;return checkRegisterForm()&quot;&gt; &lt;p id=&quot;test-error&quot; style=&quot;color:red&quot;&gt;&lt;/p&gt; &lt;p&gt; 用户名: &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/p&gt; &lt;p&gt; 口令: &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/p&gt; &lt;p&gt; 重复口令: &lt;input type=&quot;password&quot; id=&quot;password-2&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt; &lt;/p&gt; &lt;/form&gt; &lt;!-- JavaScript 内容 --&gt; &lt;script&gt; var checkRegisterForm = function () { let usc = 0, psc = 0, in_us = document.getElementById('username'), in_ps = document.getElementById('password'), in_ps2 = document.getElementById('password-2'); let usexp = /[0-9a-zA-Z]{3,10}/, psexp = /[\\S]{6,20}/; if(usexp.test(in_us.value)) {usc += 1;} if(!usexp.test(in_us.value)) {window.alert('用户名必须是3-10位英文字母或数字；'); return false;} if(psexp.test(in_ps.value)){psc += 1;} if(!psexp.test(in_ps.value)) {window.alert('口令必须是6-20位；'); return false;} if(in_ps.value!==in_ps2.value) {psc--; window.alert('两次口令必须一致；'); return false;} return usc&amp;&amp;psc; } &lt;/script&gt; 操作文件 以预览图片为例 &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt;图片预览：&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;div id=&quot;test-image-preview&quot; style=&quot;border: 3px solid #ff0000; border-radius: 10px; width: 33%; height: 200px; background-size: contain; background-repeat: no-repeat; background-position: center center;&quot;&gt; &lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; id=&quot;test-image-file&quot; name=&quot;test&quot;&gt; &lt;/p&gt; &lt;p id=&quot;test-file-info&quot;&gt;没有选择文件&lt;/p&gt; &lt;/form&gt; js代码及说明 FileReader()对象用来读取文件； element.target.result将图片编码为base64数据； preview.style.backgroundImage = 'url(' + data + ')';显示图片； //确定js在HTML后加载 window.onload = function() { var fileInput = document.getElementById('test-image-file'), info = document.getElementById('test-file-info'), preview = document.getElementById('test-image-preview'); // 监听change事件: fileInput.addEventListener(&quot;change&quot;, previewFunc); function previewFunc () { // 清除背景图片: preview.style.backgroundImage = ''; // 检查文件是否选择: if (!fileInput.value) { info.innerHTML = '没有选择文件'; return; } // 获取File引用: var file = fileInput.files[0]; // 获取File信息: info.innerHTML = '文件: ' + file.name + '&lt;br&gt;' + '大小: ' + file.size + '&lt;br&gt;' + '修改: ' + file.lastModified; if (file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif') { alert('不是有效的图片文件!'); return; } // 读取文件: var reader = new FileReader(); reader.onload = function(e) { var data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage = 'url(' + data + ')'; console.log(data); }; // 以DataURL的形式读取文件: reader.readAsDataURL(file); } } //确定js在HTML后加载 AJAX入门 var xhttp = new XMLHttpRequest();创建xhttp为名的XMLHttpRequest的对象； xhttp.onreadystatechange = function() { ... }当XMLHttpRequest的状态改变时回调函数； xmlhttp.readyState： 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 xmlhttp.status： 200: &quot;OK&quot; 404: 未找到页面 xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/gethint.php?q=&quot;+str,true); xmlhttp.send(); open(method,url,async)使readyState改变： method：请求的类型；GET 或 POST，大小写均可； ","link":"https://foreup.github.io/post/0131-dom-wen-jian-ajax/"},{"title":"0130-继承-DOM-HTML排序","content":"原型继承 创建新函数，并使用call()绑定this； 使用空函数new F()指向父原型； 修复子原型的constructor为子原型； 尽量将封装一个inherits函数实现继承； 例子 function inherits(Child, Parent) { var F = function () {}; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; } 通过inherits继承原型 function Student(props) { this.name = props.name || 'Unnamed'; } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); } function PrimaryStudent(props) { Student.call(this, props); this.grade = props.grade || 1; } // 实现原型继承链: inherits(PrimaryStudent, Student); // 绑定其他方法到PrimaryStudent原型: PrimaryStudent.prototype.getGrade = function () { return this.grade; }; ES6新增的class可以使原型的继承更为简单 //父对象模型 class Student { constructor(name) { this.name = name; } hello() { alert('Hello, ' + this.name + '!'); } } //新建对象 var xiaoming = new Student('小明'); xiaoming.hello(); //子对象模型 class PrimaryStudent extends Student { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert('I am at grade ' + this.grade); } } DOM选择相关 document.getElementById() //具有唯一性 document.getElementsByTagName() //不具有唯一性，返回一组DOM节点 document.getElementsByClassName() //不具有唯一性 // 先定位ID为'test-table'的节点，再返回其内部所有tr节点： var trs = document.getElementById('test-table').getElementsByTagName('tr'); // 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点： var reds = document.getElementById('test-div').getElementsByClassName('red'); // 获取节点test下的所有直属子节点: var cs = test.children; // 获取节点test下第一个、最后一个子节点： var first = test.firstElementChild; var last = test.lastElementChild; // 通过querySelector获取ID为q1的节点： var q1 = document.querySelector('#q1'); // 通过querySelectorAll获取q1节点内的符合条件的所有节点： var ps = q1.querySelectorAll('div.highlighted &gt; p'); //练习，评论区回答 var arr = document.querySelectorAll('.c-red.c-green&gt;p'); var arr = document.getElementsByClassName('c-red c-green')[0].children; var arr = document.querySelectorAll(&quot;.c-red.c-green p&quot;); // 选择&lt;p&gt;Haskell&lt;/p&gt;: var haskell = document.querySelector(&quot;#test-div div:last-child p:last-child&quot;); p.innerHTML = 'ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ'; p.innerText = 'ABC'; // 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt; var p = document.getElementById('p-id'); // 设置CSS: p.style.color = '#ff0000'; p.style.fontSize = '20px'; p.style.paddingTop = '2em'; 插入DOM 插入最后 DOM节点为空，如，&lt;div&gt;&lt;/div&gt;，使用innerHTML = '&lt;span&gt;child&lt;/span&gt;'插入新的子节点，但会覆盖原来的子节点； 若非空，则可以用appendChild把一个子节点添加到父节点的最后一个子节点。 原结构： &lt;!-- HTML结构 --&gt; &lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt; &lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt; &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt; &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt; &lt;/div&gt; 把&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;添加到&lt;div id=&quot;list&quot;&gt;的最后一项： var js = document.getElementById('js'), list = document.getElementById('list'); list.appendChild(js); 修改后的结构： &lt;!-- HTML结构 --&gt; &lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt; &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt; &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt; &lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt; &lt;/div&gt; 上面是把之前存在的节点移动到新位置，更多需要新建节点，应该如下： 新语句： document.createElement('p');——创建元素； d.setAttribute('type', 'text/css');——设置对象属性； var list = document.getElementById('list'), haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.appendChild(haskell); var d = document.createElement('style'); d.setAttribute('type', 'text/css'); d.innerHTML = 'p { color: red }'; //‘p’用来确定是&lt;p&gt;还是其他，如&lt;h1&gt;等； document.getElementsByTagName('head')[0].appendChild(d); 插入指定位置 使用parentElement.insertBefore(newElement, referenceElement);，插入到referenceElement之前 &lt;!-- HTML结构 --&gt; &lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt; &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt; &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var list = document.getElementById('list'), ref = document.getElementById('python'), haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.insertBefore(haskell, ref); &lt;/script&gt; &lt;!-- *新* HTML结构 --&gt; &lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt; &lt;p id=&quot;haskell&quot;&gt;Haskell&lt;/p&gt; &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt; &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt; &lt;/div&gt; 循环一个父节点的所有子节点，可以通过迭代children属性实现将所有子节点写入某数组中； 复习下面的代码： &lt;!-- HTML结构 --&gt; &lt;ol id=&quot;test-list&quot;&gt; &lt;li class=&quot;lang&quot;&gt;Scheme&lt;/li&gt; &lt;li class=&quot;lang&quot;&gt;JavaScript&lt;/li&gt; &lt;li class=&quot;lang&quot;&gt;Python&lt;/li&gt; &lt;li class=&quot;lang&quot;&gt;Ruby&lt;/li&gt; &lt;li class=&quot;lang&quot;&gt;Haskell&lt;/li&gt; &lt;/ol&gt; 对HTML内容排序 //直接排序 list = document.getElementById('test-list'); sort = Array.from(list.children).sort((a, b) =&gt; a.innerText &gt; b.innerText ? 1:-1); for (let e of sort) list.appendChild(e); //获取文本排序后返回 list = Array.from(document.getElementById('test-list').children); sort = list.map(element =&gt; element.innerText).sort(); list.map((element, index) =&gt; element.innerText = sort[index]) //自己最开始写的笨方法 let c = []; let pz = document.getElementById('test-list'); for(let i = 0; i &lt; pz.children.length; i++){ c[i] = pz.children[i].innerText; } let s = c.sort(); let ht; for (x of s){ ht = ht + '&lt;li class=&quot;lang&quot;&gt;' + x +'&lt;/li&gt;' + &quot; &quot;; } ","link":"https://foreup.github.io/post/0130-dom-html-pai-xu/"},{"title":"0129小结","content":"大纲 filter去重 filter筛选数组中素数 sort()函数复习 Array对象 函数闭包 箭头函数 generator对象 正则表达与Date对象 Jason filter去重 var r, arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry']; r = arr.filter(function (element, index, self) { return self.indexOf(element) === index;}); //PS:element, index, self只是形式？不知道能不能换！ filter筛选素数 简单的方法可以考虑素数只有1和本身两个因数，麻烦的可以依据定义写函数 //获得素数函数，可以利用素数只有两个因数，下面的是麻烦的，从定义写的函数！ function get_primes(arr) { var brr = arr.filter(function(ss){ var jsw = 0; if (ss == 1) {jsw =1} else { for (var i=2; i&lt;ss; i++) { if( ss%i==0 ){ jsw = jsw +1; break;} else{ continue; } } } return !jsw; }); return brr; } //依据因数是否只有2个 arr = arr.filter(function(element, index, self){ var count = 0;//记录因数的数量 for(var i=1;i&lt;=element;i++){ if(element%i===0){ count++; } } if(element===1){ return false; } return count&lt;3; }); console.log(arr) sort函数 在3w网站学过，快速排序，按照-1,0,1的顺序，也可以排列有属性的对象 //数字小-&gt;大排序； points.sort(function(a, b){return a - b}); //随机排序数组； points.sort(function(a, b){return 0.5 - Math.random()}); //排序有属性数组,按照字母排序对象 cars.sort(function(a, b){return a.year - b.year});； function myFunction() { var cars = [{type:&quot;BMW&quot;, year:2017},{type:&quot;Audi&quot;, year:2019},{type:&quot;porsche&quot;, year:2018}]; cars.sort(function(a, b){ var x = a.type.toLowerCase(); var y = b.type.toLowerCase(); if (x &lt; y) {return -1;} if (x &gt; y) {return 1;} return 0; }); displayCars(); } Array every var arr = ['Apple', 'pear', 'orange']; console.log(arr.every(function (s) { return s.length &gt; 0; })); // true, 因为每个元素都满足s.length&gt;0 find 查找符合条件的第一个元素，如果找到了，返回这个元素；否则返回undefined var arr = ['Apple', 'pear', 'orange']; console.log(arr.find(function (s) { return s.toLowerCase() === s; })); // 'pear', 因为pear全部是小写 findIndex 和find类似，区别：findIndex()会返回这个元素的索引，如果没有找到，返回-1; forEach forEach()和map()类似，但不会返回新数组; 函数闭包 把函数作为结果值返回，返回函数不要引用任何循环变量，或者后续会发生变化的变量：再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push((function (n) { return function () { return n * n; } })(i)); } return arr; } var results = count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; f1(); // 1 f2(); // 4 f3(); // 9 用了一个“创建一个匿名函数并立刻执行”的语法： (function (x) { return x * x; })(3); // 9 只有函数的语言里，借助闭包，可以封装一个私有变量。我们用JavaScript创建一个计数器： 'use strict'; function create_counter(initial) { var x = initial || 0; return { inc: function () { x += 1; return x; } } } 使用： var c1 = create_counter(); c1.inc(); // 1 c1.inc(); // 2 c1.inc(); // 3 var c2 = create_counter(10); c2.inc(); // 11 c2.inc(); // 12 c2.inc(); // 13 闭包可以把多参数的函数变成单参数的函数: function make_pow(n) { return function (x) { return Math.pow(x, n); } } // 创建两个新函数: var pow2 = make_pow(2); var pow3 = make_pow(3); console.log(pow2(5)); // 25 console.log(pow3(7)); // 343 箭头函数 this的指向与标准function不同，始终指向词法作用域(还是挺糊涂的，以后遇到实例再说吧)； var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = function () { return new Date().getFullYear() - this.birth; // this指向window或undefined }; return fn(); } }; 箭头函数修复了this的指向 var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); } }; obj.getAge(); // 25 generator generator由function*定义，可以用yield多次返回，也可以和函数一样用return返回一次。 function* fib2(max){ var a=0, b=1, t; for (var i = 0; i&lt;max; i++) { t=a; //也可以直接执行 yield a; [a,b]=[b,a+b]; yield t; } } //generator的调用，有两种方式 for (var shc of fib2(5)){ console.log(shc); } 也可以用next()调用； var f = fib(5); f.next(); // {value: 0, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 2, done: false} f.next(); // {value: 3, done: false} f.next(); // {value: undefined, done: true} 学了AJAX以后可以体会到generator更大的好处，目前只知道可以保存函数的中间状态； RegExp相关 基本知识 \\w可以匹配一个字母或数字，\\d匹配一个数字； +表示至少一个字符：\\s+表示至少有一个空格； *表示任意个字符，?表示0个或1个字符； \\d{3,8}表示3-8个数字，如'1234567'等； 匹配'010-12345'，-是特殊字符，需要转义，所以号码的正则是\\d{3}\\-\\d{3,8}； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*表示由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串； A|B可以匹配A或B：(J|j)ava(S|s)cript； ^表示行的开头，^\\d必须以数字开头； $表示行的结束，\\d$必须以数字结束：js也可以匹配jsp，但js$只能匹配js; 创建正则表达式： var re1 = /ABC\\-001/; var re2 = new RegExp('ABC\\\\-001'); re1; // /ABC\\-001/ re2; // /ABC\\-001/ 切分字符串 'a b c'.split(' '); // ['a', 'b', '', '', 'c']; 'a b c'.split(/\\s+/); // ['a', 'b', 'c']; 'a,b, c d'.split(/[\\s\\,]+/); // ['a', 'b', 'c', 'd']; //至少一个[' '或','或';'] 'a,b;; c d'.split(/[\\s\\,\\;]+/); // ['a', 'b', 'c', 'd']; 分组 除了匹配外，正则还可以提取字符串，()表示的就是要提取的分组； //先匹配字符串 var re = /^(\\d{3})-(\\d{3,8})$/; re.exec('010-12345'); // ['010-12345', '010', '12345'] re.exec('010 12345'); // null exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串；失败则会返回null。 var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/; re.exec('19:05:30'); // ['19:05:30', '19', '05', '30'] 上述可以识别合法日期。 但是对于日期的识别可能会出问题： var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/; 对于'2-30'，'4-31'非法日期正则很难去识别，需要程序实现； 贪婪匹配：正则默认贪婪匹配 var re = /^(\\d+)(0*)$/; re.exec('102300'); // ['102300', '102300', ''] 导致0*无法匹配到字符串，可以加个？来解决(尽可能少匹配)： var re = /^(\\d+?)(0*)$/; re.exec('102300'); // ['102300', '1023', '00'] 全局匹配 g，表示全局匹配；i，表示忽略大小写；m，表示多行匹配。 var r1 = /test/g; // 等价于: var r2 = new RegExp('test', 'g'); 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串，指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引： var s = 'JavaScript, VBScript, JScript and ECMAScript'; var re=/[a-zA-Z]+Script/g; // 使用全局匹配: re.exec(s); // ['JavaScript'] re.lastIndex; // 10 re.exec(s); // ['VBScript'] re.lastIndex; // 20 re.exec(s); // ['JScript'] re.lastIndex; // 29 re.exec(s); // ['ECMAScript'] re.lastIndex; // 44 re.exec(s); // null，直到结束仍没有匹配到 全局匹配不能使用不能使用/^...$/ Jason学习 学习中看了篇评论区文章，箭头函数不乱用，箭头函数本身无this、arguments等属性，使用箭头函数一定要在外层套一层函数，使this在可见范围内，对象无法分割作用域（对象内的箭头函数无法确定this的指向），定义变量const&gt;let&gt;var尽量依次使用。 创建对象 通过函数创建对象，理解还较浅，注意prototype与__proto__以及原型链 function Cat(name) { this.name = name; } Cat.prototype.say = function(){ return 'Hello, ' + this.name + '!'; } 可以用一个createStudent来内部封装new function Student(props) { this.name = props.name || '匿名'; this.grade = props.grade || 1; } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); } function createStudent(props) { return new Student(props || {}) } createStudent的参数非常灵活，可以不传也可以如下： var xiaoming = createStudent({ name: '小明' }); xiaoming.grade; ","link":"https://foreup.github.io/post/0129-xiao-jie/"},{"title":"0128小结","content":"看完了w3school JS教程发现教程太长，太啰嗦了，太基础了，各种重复，因此打算去**廖雪峰** 那学，过几天看看效果吧，下面看看今天在 w3那总结的东西： &lt;script&gt; myarray.foreach() function myFunction(value, index, array) { txt = txt + value + &quot;&lt;br&gt;&quot;; } //value:项目值，index：索引，array：数组本身； myarray.map() //对每个元素执行函数创建新数组，不会对没有值元素执行，不改变原来数组； numbers.reduce(function1,100) // return total + value; total 总数（初始值/先前返回的值）,可定义一个初始值, reduceRight() var over18 = numbers.filter(myFunction); //function{ return value &gt;18 ; },创建通过测试的新数组； numbers.every() //方法检查所有数组值是否通过测试,some()检查某些数组值. mynum.find() //方法返回通过测试函数的第一个数组元素的值,findIndex()返回索引； -----'日期'------ new Date(2018, 11, 24, 10, 33, 30); //年、月、日、小时、分钟、秒,0为一月； var d = new Date(&quot;October 13, 2014 11:13:00&quot;); //日期存储为自 1970 年 1 月 1 日 00:00:00 UTC以来的毫秒数; document.getElementById(&quot;demo&quot;).innerHTML = d; //d为日期对象，会使用 toString()自动转换为字符串； d.toUTCString(); d.toDateString(); //转换为易读的日期字符串 ISO日期格式：&quot;2018-02-19&quot; （国际标准），严格符合JS标准 new Date(&quot;2019&quot;); 与 new Date(2019); 不同； 短日期通常使用 &quot;MM/DD/YYYY&quot; 格式； var d = new Date(); d.getDate() 以数值返回天（1-31） d.getUTCDate() d.getDay() 以数值获取周名（0-6） d.getFullYear() 获取四位的年（yyyy） d.getHours() 获取小时（0-23） d.getMilliseconds() 获取毫秒（0-999） d.getMinutes() 获取分（0-59） d.getMonth() 获取月（0-11） d.getSeconds() 获取秒（0-59） d.getTime() 获取时间（从 1970 年 1 月 1 日至今的毫秒数） -----'数学'------ Math.round(x) 返回 x 四舍五入为最接近的整数； Math.pow(x, y) 返回 x 的 y 次幂； Math.sqrt(x) 返回 x 的平方根； Math.ceil(x) 返回 x '上舍入' 最接近的整数 Math.floor(x) '下舍入' Math.sin(x) 返回角 x弧度 的正弦 &lt;/script&gt; &lt;script&gt; var add = (function () { var counter = 0; return function () {counter += 1; return counter;} })(); function myFunction(){ document.getElementById(&quot;demo&quot;).innerHTML = add(); } &lt;/script&gt; 廖雪峰中个人认为有用的练习 2.不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数 &lt;script&gt; var s = '123456789'; var arr = []; for( var a of s ){ arr.push(a) } console.log(arr); //ASCII码，数字字符的ASCII码 - '0'的ASCII码值 = 数字字符的数值 //var brr = arr.map(function(x){ return x - '0' ;}); var brr = arr.map(function(x){ return x * 1;}); console.log(brr); //转换为整数 var c = brr.reduce(function(x,y){ return x * 10 + y; }); console.log(c); &lt;/script&gt; 3.把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字 &lt;script&gt; var arr = ['adam', 'LISA', 'barT']; var l3arr = arr.map(function(x){return x[0].toUpperCase()+x.slice(1).toLowerCase();}); console.log(l3arr); &lt;/script&gt; ","link":"https://foreup.github.io/post/0128-xiao-jie/"},{"title":"0127学习笔记","content":"&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;学过的语法记录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;&quot;&gt; /*onchange HTML 元素已被改变 onclick 用户点击了 HTML 元素 onmouseover 用户把鼠标移动到 HTML 元素上 onmouseout 用户把鼠标移开 HTML 元素 onkeydown 用户按下键盘按键 onload 浏览器已经完成页面加载*/ concat() indexOf() lastIndexOf() /*搜索字符串*/ search() slice() substring() substr() -------------- replace() toUpperCase() toLowerCase() mystring.trim() -------------- 提取字符串 charAt() //返回字母 charCodeAt() // 返回编码值 str[0]; // str = &quot;HELLO WORLD&quot;，返回 H； text.match(/ain/g) // 返回数组 [ain,ain,ain] text.match(/ain/gi) // 返回数组 [ain,AIN,ain,ain] string.includes(searchvalue, start) //start 起始位置可选 text.includes(&quot;world&quot;) // 返回 true string.startsWith(searchvalue, start) text.startsWith(&quot;Hello&quot;) // 字符串以Hello开头，返回 true text.endsWith(&quot;Doe&quot;, 5) // 返回 true let text = &quot;Bill Gates&quot;; text.endsWith(&quot;Gates&quot;,10); //指定长度后必须严格和长度一致，9或11均为 false /*模板字面量*/ let text = `He's often called &quot;Johnny&quot;`; //反引号允许多行字符串 let text = `The quick the lazy dog`; let firstName = &quot;John&quot;; text = `Welcome ${firstName}!`; //字符串插值（string interpolation）,变量和表达式插入字符串 total = `Total: ${(price * (1 + VAT)).toFixed(3)}`; //price=10，VAT=0.25,； let html = `&lt;h2&gt;${header}&lt;/h2&gt;&lt;ul&gt;`; //HTML模板，具体例子太长； isNaN(x); // 返回 true，因为 x 不是数； typeof Infinity; //返回number，是超出计算的数字； 0x; //解释为16进制； number.toString(16); // 返回 80，toString()以字符串形式输出为指定进制，默认10； x.toExponential(2); //（）内为小数点后位数； mynum.toFixed(num); //num确定保留以四舍五入保留几位小数； toPrecision() 返回字符串值，指定长度的'数字' new Number(500); //不要用new定义对象，JS中对象无法进行比较； valueOf() //以数值返回数值 Number() parseInt() parseFloat() MAX_VALUE ; MIN_VALUE; 对变量、表达式或值使用数字属性，将返回 undefined; ----/数组方法/---- Array.foreach() //遍历数组 fruits.push(&quot;Lemon&quot;); // 向 fruits 添加一个新元素 (Lemon)，返回字符串长度，使用高索引添加会增加“洞/undefined” pop() //从数组中弹出元素，返回弹出的值； shift() //从首部移出元素 unshift() //从首部增加元素 delete fruits[0]; // 把 fruits 中的首个元素改为 undefined,尽量不用 myarray.toString() //把数组转换为数组值（逗号分隔）的字符串 myarray.join() //可以规定结合成为字符串的分割符 fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;); //第二个参数（0）定义应删除多少元素,返回一个包含已删除项的数组 fruits.splice(0, 1); // 删除 fruits 中的第一个元素 fruits.slice() //用fruits的某个片段切出新数组,不删除改变fruits，start位置(,end位置)； fruits.sort() //方法是最强大的数组方法之一,按字母排序； points.sort(function(a, b){return a - b}); //数字小-&gt;大排序； points.sort(function(a, b){return 0.5 - Math.random()}); //随机排序数组； Math.max(1, 2, 3); Math.min(1, 2, 3); cars.sort(function(a, b){return a.year - b.year}); //排序有属性数组； &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://foreup.github.io/post/0127-xue-xi-bi-ji/"},{"title":"Github Pages与GRidea搭建静态博客","content":"说不清的辛酸与累啊，以后看情况更新今天所经历的挫折吧！ FLAG：每日一篇总结性文章（包括前端学习、C++学习等） ","link":"https://foreup.github.io/post/github-pages-yu-gridea-da-jian-jing-tai-bo-ke/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://foreup.github.io/post/hello-gridea/"}]}